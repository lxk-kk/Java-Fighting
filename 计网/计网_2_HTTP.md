### 计网_HTTP

#### WWW

+ 万维网（WWW，World Wide Web）是将互联网中的信息 以 超文本的形式展现的系统，也叫做 Web。

  可以显示 WWW 信息的客户端软件称为 Web 浏览器。

+ WWW 定义了 3 个重要概念，分别是 访问信息的手段和位置：URI（Uniform Resource Identifier）、信息的表现形式：HTML（HyperText Markup Language） 以及 信息转发：HTTP（HyperText Transfer Protocol）！

#### URI

+ *URI 、URL、URN*

  URI（Uniform Resource Identifier）：统一资源标识符：用字符串标识网络中的某个资源！

  URL（Uniform Resource Locator）  ：统一资源定位符：标识 网络中资源 的具体位置！

  URN（Uniform Resource Name）    ：统一资源名称：用特定命令空间的名字标识资源！

+ **URL 与 URN 是 URI 的子集**

  <img src="image\URI.png" style="zoom:67%;" />

+ 绝对的 URI 格式

  ![](image\URI 格式.png)

  ```
  协议方案名：[ http: 或者 https ] 也可以使用 data: javascript: 这类指定数据或脚本程序的方案名
  登录信息：[ user:pass ]（可选） 指定用户名和密码 作为 从服务器端获取资源时必要的登录信息
  服务器地址：[ www.example.jp ]
  服务器端口：[ 80 ]
  带层次的文件路径：[ /dir/index.html ] 指定服务器上的文件路几个来定位特指的资源
  查询字符串：[ uid=1 ]（可选） 对已指定的文件路径内的资源，可以使用查询字符传入任意参数
  片段标识符：[ ch1 ]（可选） 使用片段标识符通常可标记出以获取资源中的资源！
  ```

  除开上述可选项，就能看作一个 URL

#### HTTP 协议

+ HTTP（超文本传输协议）是将 万维网系统 中的 超文本 传输到 本地浏览器 的协议！

+ 特点

  1. 无状态

     HTTP 是一种无状态协议，它自身不会对 请求和响应 之间的通信状态进行保存！

     每当 有新请求发送时，就会有对应的新响应产生，协议本身并不保留之前一切的请求或响应报文的信息！

     之所以把 HTTP 设计的如此简单是因为：这能更快的处理大量事务，确保协议的可伸缩性。

     HTTP 1.1 虽然是 无状态协议，但是为了实现期望的 保持状态的功能，于是引入了 Cookie 技术！

  2. 多种数据传输格式

     HTTP 通过在 首部指定 Content-Type 属性，可以传输多种数据格式！

  3. 多种数据请求方法

     get、post、delete、put、patch... ...

##### HTTP 报文

###### 报文

+ 用于 HTTP 协议交互的信息称为报文。分为 请求报文、响应报文

  请求报文：请求端 发送的 HTTP 报文

  响应报文：响应端 发送的 HTTP 报文

  

+ 报文组成：报文首部、空行、报文主体

  报文首部又细分为：请求行/状态行、首部字段、其他（Cookie 等 RFC 中未定义的 HTTP 首部）

  首部字段 有四种：请求首部字段、响应首部字段、通用首部字段、实体首部字段！

###### 请求报文

+ 报文首部：请求行、首部字段、其他

  <img src="image\请求报文.png" style="zoom: 33%;" />

  <img src="image\请求报文_1.png" style="zoom:41%;" />

+ 请求行：请求方法、请求 URI、HTTP 版本

  上例：请求方法 ( GET ) 、请求 URI ( \ )、HTTP版本 ( HTTP/1.1 )

+ 首部字段

  请求首部字段、通用首部字段、实体首部字段

+ 其他

  可能包含 HTTP 的RFC中未定义的 首部，如：Cookie

###### 响应报文

+ 报文首部：状态行、首部字段、其他

  <img src="image\响应报文.png" style="zoom:33%;" />

  <img src="image\响应报文_1.png" style="zoom:41%;" />

+ 状态行：HTTP 版本、响应码、响应码描述（原因短语）

  上例：HTTP 版本 ( HTTP/1.1 )、响应码 ( 200 )、原因短语 ( OK )

+ 首部字段

  响应首部字段、通用首部字段、实体首部字段

+ 其他

  可能包含 HTTP 的RFC中未定义的 首部，如：Cookie

##### HTTP 方法

+ HTTP 方法用于告知 服务器 该请求的意图！请求的方法 会携带在 报文首部 的请求行中！

+ HTTP 中有如下方法：

  **GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE、CONNECT**

###### GET

+ 获取资源

  GET 方法指定资源，经过服务器处理之后，响应给 客户端

###### POST

+ 传输实体主体

  ```html
  <!--
   · GET 虽然也可以传输实体，但是 GET 的目的在于 获取资源！
   · POST 目的在于传输数据，而不是 获取响应的主体内容！
  -->
  ```

###### PUT

+ 上传文件

  要求在 报文主体中包含文件内容，服务器 会将其保存到 URI 指定的位置！

+ PUT 方法 自身不带验证机制，任何人都可以上传文件，存在安全问题，所以一般不使用该方法！

  如果配合 Web 应用程序的验证机制，或者架构设计 采用 REST（表征状态转移）标准的 Web 网站，可能会开发使用PUT 方法！

  ```html
  PUT /example.html HTTP/1.1
  Host: www.example.com
  Content-type: text/html
  Content-Length: 1500 <!-- 1500 字节的数据 -->
  
  <p>New File</p>
  ```

###### DELETE

+ 删除文件

  DELETE 方法请求服务器 删除 URL 指定的文件（与 PUT 相反）

  同 PUT 一样，自身不带验证机制！一般不使用！

  ```
  DELETE /example.html HTTP/1.1
  Host: www.example.com
  ```

###### PATCH

+ 对资源进行部分修改

  ```html
  <!--
   · patch 与 put 的区别
  	1、当资源存在时：
  		patch：更新部分
  		put：完全代替原始资源
  	2、当资源不存在时：
  		patch：可能会创建一个新资源
  		put：只对已有资源更新
  
   · 综上所述：
  	PATCH 方法类似于 saveOrUpdate
  	PUT 方法类似于 update
  -->
  ```

###### HEAD

+ 获取报文首部

  与 GET 方法一样，只是不返回报文主体部分，用于确认 URI 的有效性 以及 资源更新的日期时间等！

  ```html
  HEAD /index.html HTTP/1.1
  Host: www.example.com
  
  <!-- 响应时：返回 index.html 有关的响应首部！ -->
  ```

###### OPTIONS

+ 查询（针对 请求 URI 指定的资源）支持的方法

+ 用于：预请求，判断是否存在 CORS 跨域问题！

  ```html
  OPTIONS * HTTP/1.1
  Host: www.example.com
  
  <!-- 响应时： -->
  HTTP/1.1 200 OK
  Allow: GET,POST,HEAD,OPTIONS	<!-- 表示 服务器支持的访问方法 -->
  
  <!-- 如果实际请求的方法不在上述 允许的方法中，浏览器报错：CORS -->
  ```

###### CONNECT

+ 要求 在于 代理服务器 通信时 建立隧道，使用 SSL（Secure Sockets Layer：安全套接层） 和 TLS（Transport Layer Security：传输层安全）协议 把通信内容 加密后 经过 网络隧道 传输 —— HTTPS！

  ```html
<!-- CONNECT 代理服务器名:端口号 HTTP版本 -->
  CONNECT www.example.com:443 HTTP/1.1
  ```
  
  ![](image\HTTP CONNECT 示例图.jpg)

###### TRACE

+ 追踪路径

+ 服务器会将通信路径返回给客户端！

  发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器，数值就会 -1，当数值减为 0  时停止传输，最后接收到请求的服务器就会返回状态码 200 OK 的响应！响应中包含了 请求时的 信息！

  通常不会使用 TRACE，并且它容易收到 XST（Cross-Site Tracing：跨站追踪） 攻击，就更不会使用了！

###### GET vs POST

+ **作用**

  *GET 用于获取资源*

  *POST 用于传输实体主体！*

+ **参数**

  *GET 参数：以 查询字符的形式出现在 URL 中*

  *POST 参数：保存在实体主体中！*

  ```html
  <!--
   · 隐私安全性
  	GET 参数直接显示在 URL 中，而 POST 参数存放在 实体主体中，相对来说，GET 参数直接暴露在外！
  	POST 实际上也不能保证用户隐私，依旧能通过抓包工具（Fiddler）查看实际内容！
  
  
   · 总结：
  	POST 和 GET 的数据都不是安全的，都是明文传输！
  	
   · 安全传输：
  	1、HTTP 协议是 明文传输，如果想要安全，则可以使用 HTTPS，其内容都经过了加密！
  	2、在客户端使用插件，对 POST 的内容本地加密后，传输给 服务端！
  
   · HTTP vs HTTPS
  	使用 HTTP 时，应用层会直接将数据包交付给下一层 TCP 层，TCP 再经过握手与服务端建立连接，并发送数据，此过程没有数据加密的，明文传输！
  
  	使用 HTTPS 时，应用层将 数据包交付给 TCP 之前，会先将数据交付给 位于 http 与 tcp 中间的 ssl协议，数据包经过 ssl 加密之后，再传输给下一层！
  -->
  ```

+ **接口安全**

  *GET 方法是安全的；而 POST 不安全！*

  POST 传输的实体内容，可能是用户上传的表单，服务端会将表单内容保存到数据库中，因此数据状态会发生改变！

  ```html
  <!--
   · 安全的 HTTP 是只读的方法，它不会改变 服务端的数据状态！
  
   · HTTP 中的方法安全性：
  	安全的方法：GET、HEAD、OPTIONS
  	不安全的方法：POST、PUT、PATCH、DELETE
  -->
  ```

+ **幂等性**

  *GET 是幂等性的*

  *POST 是非幂等的*

+ **可缓存**

  *GET 获取资源，可缓存*

  *POST 不可缓存*

+ **标签**

  *GET 可被收藏为标签*

  *POST 不可被收藏为标签*：因为 POST 常用于表达提交，如果被收藏为标签，那么点击一下就会提交一个表单！

+ XMLHttpRequest 提交

  使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器都会这么做，例如：火狐就不会！

  而 GET 方法的 Header 和 Data 会一起发送！

  ```
  XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用
  ```

+ 编码

  GET ：由于 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符，就需要先进行编码！

  ​			例如：`中文` 会被转换为`%E4%B8%AD%E6%96%87`，并且`空格`会被转换为 `%20`

  POST ：支持任意 binary（包括中文）

##### HTTP 幂等性

+ 幂等
  $$
  X^1=X 并且 X^n=X
  $$

+ HTTP 幂等性

  *是指 一个 HTTP 方法，无论执行多少次，其服务端的状态和第一次执行时相同！*

+ HTTP 的幂等方法

  所有安全的方法都是 幂等的！

  在**正确的实现下 GET 、HEAD、OPTIONS 、PUT、DELETE 都是幂等的**。

  ```html
  <!--
   · GET：获取资源：多次调用结果相同
   · HEAD：与 GET 一样，只不过不返回实体内容，只获取首部！
   · OPTIONS：询问服务端支持的方法，多次请求结果是一样的！
   
   · PUT：表示资源完整，完整的替换数据库中的 实体内容，多次替换，结果一致！
   · DELETE：删除一次之后，数据库中便没有数据，调用多次，不会影响数据库状态！
  -->
  ```

  而 POST、PATCH 是非幂等的！

  ```html
  <!--
   · POST：新建实体内容：多次调用会在数据库中插入 多个实体记录 —— 数据库状态改变！
   · PATCH：资源部分更新：可能数据库中有记录版本号的字段，则多次进行部分更新，版本号就会连续改变，所以，PATCH 可能不是幂等的！
  -->
  ```

  [详见：HTTP 幂等性](https://www.jianshu.com/p/9d46a730284e)

  [深入理解：幂等性方案](https://www.cnblogs.com/javalyy/p/8882144.html)

##### HTTP 状态码

+ 状态码

  请求处理的结果：服务端是否出错、请求本身是否合法等！

+ 分为五类

  ![](image\状态码类别.png)

###### 1XX 信息

+ **100 Continue**

  表明到*目前为止请求处理正常，客户端可以继续发送请求* 或者忽略这个响应（消息队列：成功下单）

###### 2XX 成功

+ **200 OK** ：请求成功处理！

+ **204 No Content**：请求已经成功处理，但是返回的响应报文中不包含实体的主体部分！

  一般只用于 向 服务端 发送消息，而不需要返回数据时使用！

+ **206 Partial Content**

  表示客户端 进行了 范围请求，响应报文应该包含由 Content-Range 指定返回的实体内容！

###### 3XX 重定向

+ **301 Moved Permanently** ：永久重定向

  请求的资源已经被分配了新的 URI，此时应按 Location 首部字段提示的 URI 重新保存，以后使用新 URI 访问

+ **302 Found**：临时重定向

  资源临时更换位置，而非永久性的！

+ **303 See Other**：临时重定向，并要求客户端使用 GET 访问资源

  与 302 类似，但是 302 没有要求使用 GET 获取资源！

+ **307 Temporary Redirect**：临时重定向，浏览器遵守协议，不会将 POST 改成 GET

  与 302 类似，但是 302 并不会遵守协议！

【注意】

```html
<!--
 · 协议规定：服务端响应 301、302 时，浏览器禁止将 POST 更换为 GET！【实际上，并不会遵守，如下】

 · 当响应 301、302、303 时，几乎所有的浏览器都会将 请求资源的 POST 方法 修改成 GET 方法，并删除报文内的主体，修改后的请求会自动再次发送！ 

 · 307 就会乖乖的遵守协议，并不会像 302 那样叛逆！
-->
```

+ **304  Not Modified**

  GET 方法的请求报文中，报文首部 包含了 条件信息（例如：If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since），如果服务端发现不满足条件，将响应 304 状态码！

  其实与重定向没有关系！

###### 4XX 客户端错误

+ **400 Bad Request**：请求报文中出现语法错误！

+ **401 Unauthorized**：发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已经请求过一次，则此次请求表明用户认证失败！

+ **403 Forbidden**：表明请求被服务端（无理由）拒绝！

  未获得文件系统的访问授权、访问权限出现某些问题等都有可能出现 403！

+ **404 Not Found**：服务器上没有指定的资源！

###### 5XX 服务端错误

+ **500  Internal Server Error**：服务端执行出现错误！

  可能是 Web 应用存在 bug 或者 临时出现故障！

+ **503 Server Unavailable**：服务器暂时处于超负载 或者 正在停机维护，现在无法处理请求

##### HTTP 首部

###### 通用首部字段

| 首部字段名        | 说明                                           |
| ----------------- | :--------------------------------------------- |
| **Cache-Control** | 控制缓存的行为                                 |
| **Connection**    | 控制不再转发给代理的首部字段、**管理持久连接** |
| Date              | 创建报文的日期时间                             |
| Pragma            | 报文指令                                       |
| Trailer           | 报文末端的首部一览                             |
| Transfer-Encoding | 指定报文主体的传输编码方式                     |
| Upgrade           | 升级为其他协议                                 |
| Via               | 代理服务器的相关信息                           |
| Warning           | 错误通知                                       |

###### 请求首部字段

| 首部字段名                  | 说明                                            |
| --------------------------- | ----------------------------------------------- |
| **Accept**                  | 用户代理可处理的媒体类型*（同源跨域相关）*      |
| Accept-Charset              | 优先的字符集                                    |
| Accept-Encoding             | 优先的内容编码                                  |
| Accept-Language             | 优先的语言（自然语言）                          |
| **Authorization**           | Web 认证信息                                    |
| Expect                      | 期待服务器的特定行为                            |
| From                        | 用户的电子邮箱地址                              |
| **Host**                    | 请求资源所在服务器                              |
| **If-Match**（如果匹配）    | 比较实体标记（**ETag**）                        |
| **If-Modified-Since**       | 比较资源的更新时间                              |
| If-None-Match（如果不匹配） | 比较实体标记（与 If-Match 相反）                |
| If-Range                    | 资源未更新时发送实体 Byte 的范围请求            |
| If-Unmodified-Since         | 比较资源的更新时间（与 If-Modified-Since 相反） |
| Max-Forwards                | 最大传输逐跳数*（TRACE 方法就是利用这个字段）*  |
| Proxy-Authorization         | 代理服务器要求客户端的认证信息                  |
| **Range**                   | 实体的字节范围请求                              |
| Referer                     | 对请求中 URI 的原始获取方                       |
| TE                          | 传输编码的优先级                                |
| User-Agent                  | HTTP 客户端程序的信息                           |

###### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| **ETag**           | 资源的匹配信息               |
| **Location**       | 令客户端重定向至指定 URI     |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP 服务器的安装信息        |
| **Vary**           | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

###### 实体首部字段

| 首部字段名        | 说明                                     |
| ----------------- | ---------------------------------------- |
| **Allow**         | 资源可支持的 HTTP 方法*（同源跨域相关）* |
| Content-Encoding  | 实体主体适用的编码方式                   |
| Content-Language  | 实体主体的自然语言                       |
| Content-Length    | 实体主体的大小                           |
| Content-Location  | 替代对应资源的 URI                       |
| Content-MD5       | 实体主体的报文摘要                       |
| Content-Range     | 实体主体的位置范围                       |
| **Content-Type**  | 实体主体的媒体类型                       |
| **Expires**       | 实体主体过期的日期时间                   |
| **Last-Modified** | 资源的最后修改日期时间                   |

##### HTTP 连接管理

+ HTTP 1.* 连接：短连接、长连接、流水线

+ HTTP 2.0 连接：多路复用技术


###### 短连接（1.0）

+ **短连接：一次 TCP 连接只支持 一个 请求/响应 过程**！

+ *弊端*

  `一个 页面 经常会有多个 HTTP 请求获取资源，此时，一个页面的加载完成，就需要建立多个 TCP 连接，建立断开 TCP 连接是一个耗时且占用资源的过程，所以，短连接效率低下！`

  为解决上述问题：出现了长连接！

###### 长连接（1.1）

+ **长连接：一次 TCP 连接能支持多次 HTTP 通信**！

  长连接并不是永久连接，是有时间限定的！

+ HTTP 1.1 之前默认使用 短连接，如果要使用 长连接，则设置通用首部中的 Connection 属性

  >Connection: keep-alive

+ HTTP 1.1 开始默认使用 长连接，如果要关闭 长连接，则设置通用首部的 Connection 属性

  > Connection: close

+ *弊端*

  `HTTP 的长连接中，请求是串行的，如果某个请求阻塞了，那么后续请求都将阻塞，无法执行！尽管没有请求阻塞，由于受到网络延迟和带宽的影响，在一个请求被发送到服务器之间，需要等待上一个请求的返回，每个请求至少要等待 一个 RTT（往返延迟） ！`

  在未收到 请求的响应到来之前，下一个请求将被阻塞，这就是 `“队头阻塞”（Head-of-line blocking：HOLB）`

  为解决上述问题：出现了 pipelining 流水线连接！

###### 流水线（1.1）

+ **pipelining**

  **在一个 TCP 连接上，允许同时发出多个 HTTP 请求，而不必等待响应后再发送，服务器收到请求后，会按照请求到达的顺序处理，并依次响应给客户端**！

+ pipelining（流水线）将串行的请求，变成 并行 请求，能极大的减低延迟！

  <img src="image\HTTP 1.x 连接.png" style="zoom: 50%;" />

+ *弊端*

  `实际上 pipelining 只解决了 串行请求 的问题，而响应依旧是 串行 返回的，并没有将整个 HTTP 通信变成并行通信！`

  为解决上述问题：HTTP2.0 提出了 多路复用（Multiplexing）技术！

###### 多路复用（2.0）

+ **Multiplexing 技术**

  **所有的请求共用一个 TCP 连接，允许多个 请求和响应 的双向并发执行，彻底解决了 HOLB 问题！此外，还允许为请求添加优先级，服务端会优先响应优先级高的请求！**

  Multiplexing 技术基于 SPDY 协议，用以最小化网络延迟，提升网络速度，优化用户网络使用体验！

  注意：HTTP 2.0 必须采用 SSL 安全连接！

  <img src="image\HTTP2.0 Multiplexing.png" style="zoom:150%;" />



##### Cookie

+ *HTTP 无状态*

  HTTP 是一种无状态协议，它自身不会对 请求和响应 之间的通信状态进行保存！也就是说无法根据之前的状态，处理本次的请求！

  每当 有新请求发送时，就会有对应的新响应产生，协议本身并不保留之前一切的请求或响应报文的信息！

  `优点`：这能更快的处理大量事务，确保协议的可伸缩性。

  `缺点`：要求登录认证的 Web 页面 无法进行状态管理时，每次跳转新页面都需要重新登录！

  Cookie：HTTP 1.1 虽然是 无状态协议，但是为了实现期望的 保持状态的功能，于是引入了 Cookie 技术！

+ Cookie 用于 **用户识别 与 状态管理**，弥补了 HTTP 无状态协议 的缺点！

  Cookie 只能用于保存少量信息！

  [HTTP Cookie](https://blog.csdn.net/longgege001/article/details/81274088)

###### Cookie 机制

+ Cookie 生成 与 存储

  ```html
  <!--
   · Cookie 的内容由 服务端生成，由 客户端 存储！
   
   · Cookie 机制：
  	
  	1、最开始，客户端无 Cookie 时访问 服务端，服务端会将 客户端 的状态信息写入 首部字段Set-Cookie 中，并响应客户端，客户端响应之后，将 Cookie 本地存储！
   	
  	2、下一次请求时，会自动携带上 Cookie 的内容访问服务端！服务端便取出 请求报文中的 Cookie 信息，得到之前的状态信息，并维持之前的访问状态！
  -->
  ```

+ cookie 规范（`Set-Cookie`） 定义了服务器和客户端交互信息的格式、生存期、使用范围、安全性！

+ Set-Cookie 首部字段

  属性：*expires、domain、HttpOnly、secure*

###### Cookie 生存期

+ **expires 属性** 指定了*该 cookie 的过期时间* ！

  如果不指定，则默认为 浏览器关闭之后就会被自动清除

  *Set-Cookie: id=a3fWa; expires=Wed, 21 Oct 2015 07:28:00 GMT;*

+ 或者`可以通过Cache-Controle 中的 max-age 属性指定其 存活时长`！

###### Cookie 可用范围

+ **domain 属性**指定了*可以接受 该cookie 的主机* ！

  如果不指定，**默认为 当前文档的主机**（不包含 子域名）

  如果指定，则一般包含子域名

  *例如：domain= .mozilla.org 则，Cookie 也包含在其子域名中：developer.mozilla.org*

  > 将 cookie 的域设置为高级域名，那么低级域名的所有请求可以使用：**单点登录**
  >
  > + 例如：domain = .example.com
  >
  >   那么 .example.com 的所有子域名都能访问该 cookie 
  >
  >   即：career.example.com	developer.example.com admin.example.com 等子域名都能使用！

+ **Path 属性**指定了 *主机下的哪些 路径 可以接受 Cookie*（该 URL 路径必须存在于 请求 URL 中）

  路径以 反斜杠 作为分隔符，并且 Path 的子路径也会被匹配。

  例如：Path=/docs 则 /docs	/docs/Web	/docs/Web/HTTP 都会被匹配！

###### Cookie 安全性

+ **HttpOnly 属性**，标志*该 Cookie 不能被 JavaScript 脚本调用，避免 Cookie 的 XSS 攻击* ！

  ```
  浏览器通过 js 脚本：document.cookie 可以创建新 Cookie！
  
  跨站脚本攻击（XSS）就常常使用 js 的 document.cookie API 窃取用户的 Cookie 信息！
  ```

  因此，使用 HttpOnly 能一定程度上避免 XSS 攻击！

+ **Secure 属性**，标志着 *Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端* ！

  即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 也无法提供确实的安全保障！

##### Session

###### session 机制

1. session 表示会话，用于保存用户的信息、登录状态。在 服务端创建，并保存在服务端内存中！

2. session 机制

   ```html
   <!--
    · session 创建
   	1、客户端第一次访问服务端时，服务端 为其创建一个 管理会话信息的 session，并将 session 保存在内存中！同时将唯一标志这个 session 的 session id 保存在 cookie 中，响应给客户端！
   	
   	2、客户端收到响应后，将 cookie 保存在本地，下次请求时将 cookie 中的 session id 携带上！
   	3、服务端收到带有 session id 的cookie 之后，就会在内存中查找 对应的 session 是否存在！
   	  如果存在：直接将该 session 取出，作为用户当前的 状态！
   	  如果不存在：创建新 session，同时用新的 session id 覆盖 cookie 中旧的 session id，响应给客户端！
   -->
   ```

###### 服务端 session 不共享

+ 假如两个服务端都在内存中保存 session ，那么，两个服务端的 session 是不共享的，尽管是在 同一个 主机上！

+ 正是由于 两个服务端的 session 不共享，所以，各自不知道 用户 是否在对方的应用上登陆过，也不知道 用户在对方应用上的状态！

  所以：当 用户携带者对方的 session id 访问自己时，查不到 用户的信息，于是就会新建一个 session，并覆盖 请求中的 session id！

+ 场景：

  在分布式系统中，将业务拆分时，不同的业务单独作为一个服务，业务之间相互连接变成了一个系统。用户在该系统的不同业务之间跳转时，访问的便是不同的服务端。

  由于session存放着用户的身份信息和权限信息，所以如果session不能共享，整个系统的功能便失去了意义。

  例如：系统可能会重复的要求用户登录。	

###### session id 覆盖

+ 现象

  由 session 机制可看出，当 服务端查询不到 cookie 中携带的 session id 时，就会将其覆盖！

+ 原因：

  当两个 web 应用的 session id 这个 cookie 在同一个`cookie域`内时（cookie 的 domain 相同，并且 path 也相同），就会出现 session 覆盖问题！因为，在浏览器端，两个应用的 cookie 是存放在一起的！

+ 实质 是 cookie 共享的问题！

  实际上出现 session id 覆盖，是因为，两个应用在浏览器端，共享了 同一个 session id  这个 cookie ！

  + 当两个 Web 应用的  cookie 在同一个`cookie域`内`(domain 、 path 都相同)`，则两个 应用 共享的cookie！

  + 当两个 Web 应用的 cookie 的作用域互不相干时，两着 cookie 存储也互不相干！

  + 两个个 Web 应用的 cookie 作用域 出现包含关系时，作用域小的 将可以 使用 作用域大的 cookie，而 作用域大的，却不能使用 作用域小的 cookie ！

     包含关系时:

    ```html
    <!--
     · 如：cookieA 为 二级域名，而 cookieB 是一级域名：则浏览器会将 cookieB 的所有内容，添加到 A 的请求中，访问 serverA ：A 使用了 B 的cookie！
    
     · 或如：cookieA 的 path 为子目录，而 cookieB 的 path 为 cookieA 的父目录，那么，A 的请求中，依旧会携带上 B 的cookie ：A 使用了 B 的cookie！
    
     · 但是，B 不能使用到 A 的 cookie：因为，浏览器是按照 URL 前缀匹配的！
    -->
    ```

  [在不同 Web 应用之间共享数据](https://blog.csdn.net/colinmuxi/article/details/12679271)

+ cookie共享 示例：

  如下：8081 端口的应用 A

  ![](image\cookie 作用域_1.png)

  如下：8080 端口的应用 B

  ![](image\cookie 作用域_2.png)

  解答：

  ​		上述 A、B 应用的 JSESSIONID 生成时，使用的是默认的 `domain 和 path（与 端口无关）`，所以 A 与 B 的 JESSIONID 的 `cookie域`完全相同，此时，A、B 之间访问时，会出现 session id 覆盖的问题！

  ​		而 A 中的 confirm 这个 cookie 的 `path域`包含了 B ，所以，匹配 B 的cookie 时，A 的 confirm 这个 cookie 也会被匹配出来！

##### Cookie vs Session

+ **Cookie 只能存储 ASCII 码**，而 **Session 可以存储任何类型的 数据**，因此在 数据复杂性方面，优选 Session
+ **Cookie 存储在浏览器中，容易被恶意查看（XSS攻击）**。如果非要将隐私数据存入 Cookie 中，**可以将 Cookie 值加密，然后在服务端进行加密**！
+ 对于大型网站，**如果用户所有的信息都存放在 session 中，那是会非常消耗资源的**，因此不建议将所有用户的信息都存放在 session 中！

##### HTTP ETag

###### 介绍

+ ETag 是 HTTP 1.1 新增的响应首部字段，它由服务端控制，表示某一个 URL 下的资源标识

  *ETag : "82e22293907ce725faf67773957acd12"*

  ```
  	URL 只是资源定位符，同一个 URL 下的资源，其内容会发生变化，例如：资源被修改。并且，对于国际化来说，同一个 URL 展示的资源是不同的 语言。
  	
  	而：对 ETag 而言 ，同一个 URL 下的资源被修改后，ETag 也会修改！
  ```

###### ETag 资源有效性验证

+ ETag 伴随着 If-Match（如果匹配）、If-None-Match（如果不匹配）头部一起使用！

+ 第一次请求时：

  1. 客户端发器 HTTP GET 请求资源
  2. 服务端处理请求，并将资源响应给客户端，同时，为资源生成 ETag 值，一同响应！

+ 第二次相同资源的请求：

  1. 客户端发起 HTTP GET 请求资源，同时在请求头部中加入 If-None-Match 头部，其值为上一次资源请求的 ETag 值！

     > If-Not-Match "82e22293907ce725faf67773957acd12"

  2. 服务端将 If-None-Match 的值 与 现有资源的 ETag 值做比较！

     如果 If-None-Match 为 false 返回 304，表示资源 ETag 匹配，资源未被修改，客户端可使用本地缓存！（Cache-Control 默认值为 private）

     如果 If-None-Match 为 true，则重新返回资源 及 ETag 并响应 200！

+ 如果 开始时服务端为资源设置了 Cache-Control:max-age 以及 Expires 那么，客户端再次请求时，将会带上 If-Modified-Since ！

  此时 服务端验证时，将会同时验证 If-None-Match 与 If-Modified-Since 当两者都满足条件后，才会返回 304！

###### ETag vs Last-Modified

+ Last-Modified 是HTTP1.1 之前就存在的首部字段，用于判断资源的更新情况，这与 ETag 的目的相同，而Last-Modified 并不完美：
  1. 一些资源可能会被周期性的修改，但是其内容并没有改变，而每一次修改都会影响到 Last-Modified，因此下一次 GET 请求时，需要重新获取资源（但实际上，缓存依旧是有效的）！
  2. 一些资源 可能会被频繁的更改，甚至 1 秒钟 之内被修改多次，而 Last-Modified 只能精确到 秒，因此这些修改，它并不能察觉到！
  3. 某些服务器 不能 精确的得到最后被修改的时间！
+ 正是由于以上问题的出现，HTTP1.1 开始新增了 ETag，其相当于资源的版本号！

###### ETag 断点续传

+ Etag 除了上述资源缓存的有效性验证的功能之外，它还支持 断点续传的功能！

+ 断点续传 ：Range + Content-Range  是 HTTP1.1 新增的 范围获取资源  的首部字段！

+ 原理：

  客户端记录当前的 资源下载进度，并在需要 续传时 将下载进度告知服务器，服务器将会 响应为下载的片段！

  但是，如何保证 在暂停下载资源之后，资源没有被更新呢 —— ETag + If-None-Match 资源有效性验证！

+ 断点续传过程：

  假设客户端下载 2000K 的资源，资源的 ETag 值为 82e22293907ce725faf67773957acd12 ！

  假设客户端下载到 500K 时，网络连接断开，重连后，客户端开始续传！

  1. 客户端请求续传，在请求报文首部中使用 Range 字段，表示需要 续传的位置！

     > Range: bytes=500000

     同时为验证资源有效性，需要通过 If-None-Match 头部验证！

     > If-None-Match "82e22293907ce725faf67773957acd12"

  2. 服务端收到 续传请求，首先验证 If-None-Match

     如果验证通过，则从资源的 500K 处开始传输，并设置响应头部 Content-Range 表示传输的数据量！

     > Content-Range:bytes =500000-2000000

     此时，响应的状态码为 206（Partial Content ），而不是 200 ！

##### HTTP 缓存

###### 优点

+ 加快请求的响应，降低用户获取资源的延时

  层层缓存，最快的是 客户端的本地缓存，每一层都比直接从服务端获取资源要快的多！

+ 降低服务端压力

  有了缓存，则并不是所有请求都需要服务端处理，客户端、代理服务器等如果存在当前请求的缓存，则可以直接返回给用户，减少了直接访问服务端的压力！

###### 缓存方式

+ 层层缓存
  1. 客户端本地缓存
  2. 代理服务器中的缓存
  3. 服务端的缓存（第三方缓存）

+ HTTP/1.1 可以通过首部字段 **Cache-Control 控制 客户端 和 代理服务器 上的缓存** ！

###### Cache-Control

+ Cache-Control 是一个 通用首部字段，用于控制 客户端 和 代理 上的缓存！

+ Cache-Control 有如下属性：

  *no-cache、no-store、private、public、max-age、s-maxage*

  *Expires 首部字段*也可以用于设置 缓存的过期时间！
  
+ **Cache-Control 默认属性为 private：表示允许浏览器端可缓存！**

###### 禁止缓存

+ **no-store 属性**表明任意网络节点 不能对该资源进行缓存！

  *Cache-Control : no-store*

###### 强制确认缓存

+ **no-cache 属性**表明 不使用过期缓存，访问资源时，客户端 或者 代理服务器 都需要向服务端 发起资源有效性认证！

  只有资源有效时，才能响应给用户！

  *Cache-Control : no-cache*

###### 公有/私有 缓存

+ **private 属性**表明 资源是私有的，只能单独被用户使用，所以代理服务器上不能缓存，只能在客户端缓存！

  *Cache-Control : private*

+ **public 属性**表明 资源是公有的，可以被多个用户使用，允许在代理服务器中缓存！

  *Cache-Control : public*

###### 缓存过期

+ **max-age 属性**表明 资源缓存的有效时长！

  出现在 请求报文中：如果资源已缓存的时长，小于 max-age 指定的时长，则缓存有效；否则 从服务端获取！

  出现在 响应报文中：表明缓存在 代理服务器中保存的时长！

  *max-age : 12321312（单位为 秒）*

+ **s-maxage 属性** 与max-age 作用一致，区别在于，s-maxage 只作用于 代理服务器！

  *s-maxage : 12321321 （单位为 秒）*

+ **Expires 首部字段**

  Expires 是实体首部字段，告知缓存的 失效日期！

  如果不想让资源被缓存时，最好将 Expires 设置为当前的 Date

  *Expires : Web, 04 Jul 2020 08:26:05 GMT（具体日期）*

  > 注意：
  >
  > + 在代理服务器中 s-maxage 将会覆盖 max-age 和 Expires
  >
  > + HTTP 1.0 中，max-age 指令会被忽略，只会处理 Expires
  >
  > + HTTP 1.1 中，比起首部字段 Expires，max-age 会优先处理

###### 缓存验证

+ **Etag + If-None-Modified 首部字段，完成资源有效性验证**

  *ETag : "82e22293907ce725faf67773957acd12"*

  > If-Not-Match "82e22293907ce725faf67773957acd12"

  ```html
  <!--
   · 可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到请求后，将现有资源的 ETag 值与 If-None-Modified 值做判断，若 If-None-Modified 值为 false，ETag 值相同，表明资源有效，并返回 304 Not Modified ！
  -->
  ```

+ **Last-Modified + If-Modified-Since 首部字段**

  *Last-Modifed : Web, 04 Jul 2020 08:26:05 GMT（精确度为 秒）*

  > If-Modified-Since : Wed, 21 Oct 2015 07:28:00 GMT

  ```html
<!--
   · 可以将缓存资源的 Last-Modified 值放入 If-Modified-Since首部，服务器收到请求后，判断在 If-Modified-Since 指定的时间之后，资源是否被修改，如果 If-Modified-Since 结果为 false，则表明资源有效，并返回 304 Not Modified ！
-->
  ```

#### HTTPS

##### HTTP 缺点

+ 通信使用明文，内容可能会被窃听！
+ 不验证通信方的身份，因此有可能遭遇伪装！
+ 无法证明报文的完整性，所以接收到的报文，有可能已遭到篡改！

##### HTTPS 介绍

+ HTTP+加密+认证+完整性保护 = HTTPS

  **HTTP 下应用端口默认在 80，而 HTTPS 是443**

+ HTTPS 并不是应用层的一种新协议！

  HTTP 通信是直接 和 TCP 交互的，然而，HTTPS 就是在 HTTP 和 TCP 之间添加一层 SSL 协议，此时 HTTP 需要先和 SSL 通信，再由 SSL 和 TCP 通信！

  <img src="image\HTTPS 结构.png" style="zoom:67%;" />

+ SSL 通过 **加密（防窃听）、认证（防伪装）、完整性性保护（防篡改）**使得 HTTPS 达到安全通信的目的！

##### 加密

###### 对称加密

+ *对称加密：加密和解密采用同一个密钥*

+ **优点**

  *运算速度快！*

+ **缺点**

  *无法安全的将密钥传输给通信方！*

<img src="image\对称加密.png" style="zoom:67%;" />

###### 非对称加密

+ 非对称加密 又称 公开密钥加密，加密和解密使用不同的密钥！

+ *非对称加密* 有*两把密钥，公钥和私钥，公钥用于发送给通信方（公有），私钥自己保留（私有）*，通过公钥加密的密文只有私钥才能解密！

  <img src="image\非对称加密.png" style="zoom:67%;" />

+ **作用**：

  + **数据加密：公钥加密，私钥解密：防止通信内容被窃取！**

    由于公钥加密之后，只有持有私钥的人才能解密，其他人尽管持有公钥，也无能为力，所以，数据加密能保证传输内容不被窃取！

    但是：由于别人也持有公钥，也能给持有私钥的接受方发送数据，因此：接收方并不能保证发送过来的数据就是目标通信方发送过来的 —— 不能保证通信的数据被篡改，狸猫换太子！

  + **数字认证：私钥加密，公钥解密：防止通信内容被篡改！**

    由于私钥是私有的，并不像公钥那样公共持有，所以，私钥可以作为 身份的象征！

    使用私钥加密的数据，接收方能明确知道数据来自私钥的持有者！此过程，别人也能解密数据，但是没有办法篡改数据 ，根本没有办法狸猫换太子！

+ **加密 与 认证**

  加密和认证两者互补，当**两者结合之后，就能保证数据可靠性传输**！

  通信双方各自持有一套 公私钥！发送方 使用接收方的公钥，能够将数据加密，防止被他人窃取！然后，再使用 自己的私钥 将 上述加密后的数据再次加密，能够防止他人篡改数据，完成身份的认证！

+ **优点**

  安全的公开密钥 —— 公钥

  加密功能、认证功能

+ **缺点**

  算法复杂度高，*运算速度慢！*

  [非对称加密：RSA 原理](https://blog.csdn.net/wjiabin/article/details/85228078)

##### HTTPS 加密方式

+ 加密

  对称加密：加解密速度快，但是密钥传输不安全！

  非对称加密：公钥可公开，可实现安全通信，但是加解密慢！

+ **HTTPS 采用混合加密的机制**，将 对称加密和非对称加密 结合，优缺点互补！

  由于通信双方可能会有大量的数据传送，使用 非对称加密虽然能够实现密钥公开，但是数据加解密过程耗时较长，因此整个通信效率非常低！

  于是 **HTTPS 的通信过程采用了对称加密的方式，而通信双方的密钥正是使用 非对称加密传送的！**

  两者结合**既保证了通信的安全，也保证了通信的效率！**

##### HTTPS CA 认证

###### 介绍

+ CA（Certificate Authority）证书：由权威认证机构颁发，用于证明公钥的身份！

+ 为什么需要 CA认证？

  CA 认证用于验证 公钥的 真实性！避免出现中间人攻击！

  ```html
  <!--
   · 虽然 HTTPS 采用了非对称加密保证 对称密钥能够安全的传送给对方！
  	但是在服务端向客户端发布公钥的过程中，很可能公钥被中间人替换，并将中间人的公钥发送给客户端！因此，这个公钥是不可信任的！
  	使用 CA 权威机构发布的证书，能够使客户端确认公钥的身份！
  -->
  ```

+ 补充：中间人攻击

  `是指 攻击者 与 通讯的两端 分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。`

  ```html
  <!--
   · 实施中间人攻击时，攻击者常考虑的方式是 ARP欺骗 或 DNS欺骗 等。
  
   · DNS欺骗（DNSSpoofing）：
  	攻击者通过入侵DNS服务器、控制路由器等方法把受害者要访问的目标机器域名对应的IP解析为攻击者所控制的机器，这样受害者原本要发送给目标机器的数据就发到了攻击者的机器上，这时攻击者就可以监听甚至修改数据，从而收集到大量的信息。
  
  	如果攻击者只是想监听双方会话的数据，他会转发所有的数据到真正的目标机器上，让目标机器进行处理，再把处理结果发回到原来的受害者机器；如果攻击者要进行彻底的破坏，他会伪装目标机器返回数据，这样受害者接收处理的就不再是原来期望的数据，而是攻击者所期望的了。
  -->
  ```

  [百度百科：中间人攻击](https://baike.baidu.com/item/中间人攻击/1739730?fr=aladdin)

  [中间人攻击：SSL证书伪造攻击、SSL 剥离攻击](https://www.jianshu.com/p/210c296eb836)

###### CA 证书机制

1. 服务端运营人员 将自己的公钥 登录到 数字认证机构。

2. 认证机构判明申请者身份之后，用机构的 私有密钥 为 服务端的公钥 部署数字签名，并为服务端颁发公钥证书！

3. 之后，进行 HTTPS 通信时，服务端会将这个公钥证书发送给客户端。

4. 客户端收到公钥证书后，使用认证机构的公钥 对 公钥证书的数字签名进行验证（使用认证机构的公钥解密其数字签名）！

   如果解密成功说明：

   + 为 服务端 颁发公钥证书的机构 是 有效的认证机构！
   + 服务端的公钥是值得信赖的！

   `认证机构的 公钥 是内置在浏览器中的！`

##### 完整性保护

+ SSL 提供报文摘要功能进行完整性保护！

  HTTP 也提供了 MD5 报文摘要功能，但是不安全。例如：报文内容被修改之后，同时重新计算 MD5 值，通信双方是无法意识到数据被篡改！

  HTTPS 的报文摘要功能 结合了 加密和认证，使得其变得安全！加密后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文？

##### HTTPS 过程

+ HTTPS 连接整个过程分为：认证阶段 和 数据通信阶段！

  <img src="image\HTTPS 过程.jpg" style="zoom:50%;" />

+ 认证阶段

  1. 客户端发送 HTTPS 请求

  2. 服务端接收到请求，将公钥证书响应给客户端！

  3. 客户端接收公钥证书，并使用 认证机构的 公钥对数字签名进行验证

     如果成功验证：表明 公钥证书可靠，继续进行下一步！

     如果验证失败：浏览器并不会强制不允许建立连接，而是给出警告，提示用户证书不合法！

  4. 验证成功 或者 验证失败并且用户一意孤行 之后，客户端会生成一个 随机数，并使用 服务端的公钥将其加密之后，传送给服务端 —— 该随机数就是此后通信的 对称密钥！

  5. 服务端接收到加密后的 随机数 之后，使用密钥对其解密，作为对称密钥！

+ 数据通信阶段

  ​	客户端和服务端之后的数据通信都会使用 对称密钥 加解密！

##### HTTPS 其他问题

1. HTTPS 会被抓包嘛？

   会！HTTPS 依旧是可以被抓包的，但是由于传输的内容被加密了，而加密的密钥别人无法得知，所以，意义不大！

   但是，如果客户端对 数字签名 认证失败后，用户一意孤行的话，那就等于同意中间人监听自己的通信过程，数据内容是会被中间人窃取的！这属于 用户主观的问题，而并非 HTTPS 功能上的问题！

2. 保存在本地的 对称密钥 被窃取怎么办？

   HTTPS 只能保证 对称密钥 能安全的传送，并不能保证本地窃取，这不在 HTTPS 的工作范围之内！

   应对这种情况，应该安装杀毒软件、木马、客户端升级修复漏洞等！

#### HTTP 1.x vs 2.0

##### HTTP 1.1 新特性

1. HTTP 1.0 的连接默认是短链接，而 HTTP1.1 默认使用长连接，并且在长连接的基础上还支持 pipelining 流水线连接！

2. 支持 虚拟主机 Host 字段

   HTTP 1.1 之前，认为 IP 与 主机是一一对应关系，所以，不需要使用 Host 字段，然而，后来出现 虚拟主机技术，使得一台服务器可以拥有多个域名，并在逻辑上视为多个服务器！此时 IP 与 主机之间并不是 一一 对应的，需要使用 Host 字段加以区分！

3. 分块传输编码（Chunked Transfer Encoding）

   将数据分割成多个块，让浏览器逐步显示！

   发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。

4. 新增 100 状态码

   100 状态码，允许客户端在发送 请求主体内容之前，先发送一个 请求头部（Expect: 100-continue头部） 试探 服务端，判断服务端是否能接收 请求主体，再决定是否需要发送 请求主体内容！

   如果服务端响应 100 则，表示愿意接收，此时再发送主体内容！如果不愿意接收，就避免了发送请求主体！节约了网络资源！

5. 添加了 ETag 首部字段，解决了 Last-Modified 出现的问题

6. 添加了 Range 首部字段，实现范围获取资源；

   Range 结合 ETag 首部字段，能够实现断点续传！

7. 新增了 缓存控制属性 max-age

##### HTTP 1.x 缺陷

+ 尽管 HTTP1.1 出现 长连接，并且支持 流水线请求处理，但是依旧没有改变 HOLB（队头阻塞） 问题！需要建立多个 TCP 连接，间接的降低网络延迟，实现并行！
+ 不会压缩请求和响应首部，从而导致不必要的网络流量！
+ 不支持有效的资源优先级，使得底层 TCP 连接的利用率低下！

##### HTTP 2.0 特性

+ Multiplexing 多路复用技术

  多路复用技术，使得 请求端和响应端之间能够实现双向的并行执行，并且，所有请求/响应都是在一个 TCP 连接中！提高了通信效率之外，还节省了系统资源！

+ 服务端推送

  HTTP 2.0 中，在客户端申请一个资源时，服务端会把相关的资源一同响应给客户端，于是客户端就不需要再次发起请求了！

  例如：客户端申请 page.html 页面，服务端就会将 script.js 和 style.css 等相关的资源一同响应！

  ![](image\HTTP 2.0 服务端推送.png)

+ 首部压缩

  HTTP 1.1 的首部带有大量的信息，而每次都需要重新发送！

  HTTP 2.0 要求客户端和服务端同时 维护和更新 一个包含之前见过的首部字段，从而避免了重复传输！

  不仅如此，HTTP 2.0 也使用了 Huffman 编码对首部字段进行压缩！

  <img src="image\HTTP 2.0 首部压缩.png" style="zoom:50%;" />

#### HTTP 请求过程

+ 网页中输入 URL 后发生了什么？

  0. 输入url

  1. Redirect跳转：可能浏览器已经记录该url，以及可能永久跳转到一个新地址，所以浏览器需要判断一下，需不需要redirect以及要redirect到哪个地方

  2. App cache查缓存：浏览器可能已经缓存了该地址，所以会去app cache进行查看，如果有则会直接返回，如果没有则需要去服务端请求数据

  3. DNS域名解析：由于输入的是域名，则需要将域名映射到ip之后才能真正的访问到服务器，所以需要查找一下域名对应的IP地址，即DNS解析

  4. TCP连接：有了IP之后，建立TCP链接：需要经历tcp的三次握手才能建立起连接。

     如果是https，则和http的三次握手不一样，因为有保证数据安全传输的过程。

  5. Request 客户端 发送请求：连接建立好以后，才会发送http请求的数据包

  6. Response 服务端响应：服务器接收到请求，并进行数据操作以后，开始响应

  7. 浏览器接收响应，展示用用户！

