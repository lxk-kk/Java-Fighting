【缓存Cache-Control】
1、特性：
	（1）可缓存性：
		public：表示http请求的返回内容（响应）所经过的所有服务器任何路径（代理服务器、发出请求的客户端等），都可以对该内容进行缓存。
				下一次相同的请求就可以直接返回缓存内容，不需要再到服务端响应。
		private：只有发起请求的浏览器客户端才能对响应内容进行缓存。
		no-cache：任何一个结点都允许缓存响应数据，但是必须要向源服务器发起请求验证是否允许使用缓存，如果允许则可以使用，如果不允许则必须要向服务器请求响应数据。
	（2）到期：
		max-age=<seconds>：设置缓存过期时长，只有过期后请求才会到达服务端，重新进行响应。
		s-maxage=<seconds>：经过代理服务器时，会代替max-age，只有再代理服务器中才会生效。其余情况下，max-age生效。
		max-stale=<seconds>：只有浏览器端才可设置。表示，如果缓存过期了，且只有还在max-stale设置的时效内，就可以直接启用缓存，而不会到源服务端请求一个新的响应。
	（3）重新验证：
		must-revalidate：用在客户端上，如果max-age设置的缓存已经过期了，则需要重新向源服务端获取响应数据验证缓存数据是否真的过期。
		proxy-revalidate：用在缓存服务器上，和must-revalidate效果一致。
	（4）其他：
		no-store：所有结点一律不能缓存数据，需要和no-cache区分。忽略任何与缓存相关的头部信息，所有请求都需要向服务端获取新的响应。
		no-transform：用于proxy服务器上，不允许这些服务器压缩数据，不允许改动响应数据。
	最后：这些头部只是一个限制性声明性的作用，它没有任何强制的约束力，即对proxy服务器来说，完全可以不遵照这些头部限制。

【资源验证】
1、http验证头：
	Last-Modified：上次修改时间，为资源设置的上次何时被修改。
		（1）主要配合If-Modified-since或者If-Unmodified-Since使用。
		（2）验证资源是否可以使用缓存的过程：
			如果请求的响应头中设置了Last-Modified时间，则在下一次浏览器发起同样请求的时候，就会通过If-Modified-Since（使用居多）或者If-Unmodified-Since带上上次响应的Last-Mofified的值，向服务器发起请求。
			服务器收到请求后，会检查header中的If-Modified-Since（或者...）的值，然后对比此资源上次修改的时间，如果时间是一样的，则表示资源没有被重新修改过，则服务器会告诉浏览器此资源的缓存可以直接使用。
	Etag：数字签名
		资源的内容有一个唯一的签名，如果对数据进行修改，则签名就会改变。典型的方法：对资源内容进行一个hash计算。
		下一次进行请求的时候，就会带上If-Match或者If-Non-Match这个头，这个头会带上上次请求响应的Etag的值。
		服务端接收到请求后，会对比资源的签名判断是否使用缓存。