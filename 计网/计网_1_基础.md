### 计网_基础

#### 各层协议

+ **OSI层协议** vs **TCP/IP四层协议** vs **五层协议**

  ![](image\各层协议.png)

##### OSI 七层模型

+ *应用层*

  **为 应用程序 提供服务，并规定 应用程序中通信相关的细节（通信协议）！**

  例如：域名系统（DNS 协议）、文件传输（FTP 协议）、电子邮件（SMTP 协议）、远程登录（TELNET 协议）、万维网应用（HTTP 协议）、简单网络管理协议（SNMP）等不同的服务需要不同的协议支持！

  应用层的数据单元称为 *报文*

+ *表示层*

  主要负责**数据格式的转换**！

  将应用处理的信息转换为适合网络传输的格式，或者 将来自下一层的数据 转换为 上层能够处理的 格式！

  就是负责 *设备固有的数据格式*  与 *网络标准的传输格式* 之间的相互转换！

  ​	对上层：将 网络传输格式 转换为 设备固有格式！

  ​	对下层：将 设备固有格式 转换为 网络传输格式！

  常见协议：MIME（SMTP 相配）、HTML（HTTP 相配）、MIB（SNMP 相配）

+ *会话层*

  主要负责**建立及管理会话**！

+ *传输层*

  **为应用层（上层）提供通用的数据传输服务**！

  **并且向高层应用 屏蔽了 底层网络的传输细节，使通信过程 看起来像是 在通信双方的 传输层之间有一条端到端的逻辑通信信道！**

  由于应用层协议很多，于是，提供通用的 传输层协议 就能支持不断增多的应用层协议！

  传输层协议包括：TCP（传输控制协议）、UDP（用户数据报协议）！

  + TCP ：提供**面向连接、可靠的数据传输服务**！数据单位为 *报文段* ！

    TCP 主要提供*完整性服务*，确保可靠连接，数据不丢失！

  + UDP：提供**无连接、尽最大努力传输服务**！数据单位为 *用户数据报* ！

    UDP 主要提供*及时性服务*，不能保证数据成功传送，数据可能丢失，并且不能保证对方是否接收到数据！

+ *网络层*

  **主要负责 目标地址的 寻址 和 路由选择！**它会基于 IP地址 将上层（传输层）传递的数据分组转发给目标地址！

  所以也 **为主机** 提供了 数据传输服务！

  注意：传输层是`为应用`提供的数据传输服务！

  网络层协议：**IP**、ICMP、ARP（查询 MAC 地址）

  使用 IP 协议时，分组后的数据单元称为 *IP数据报* 或*数据报* ！

+ *数据链路层*

  *以帧为数据单元传输* ！

  **负责物理层面上 相邻节点之间的 通信传输**，它会将`源自网络层的 IP数据报`封装成*`帧`*，可靠地传输到相邻的网络节点上！

  网络层针对的是 源主机 与 目标主机 之间的数据传输，而两个主机之间可能会有多条链路，链路层协议就是为同一链路的主机提供数据传输服务！

+ *物理层*

  物理层上传送的数据单元为 *bit（比特）*

  实现 相邻计算机节点之间 **比特流的透明传输**，**尽可能屏蔽掉 `物理设备`、`传输媒体` 以及 `通信手段`的差异**！使得数据链路层察觉不到这些差异的存在！

##### TCP/IP 四层模型

+ *应用层*

  它合并了 OSI七层协议中 应用层、表示层 以及 会话层 这三层的所有功能！

+ *网络接口层（数据链路层）*

  它合并了 OSI七层模型中的 数据链路层 和 物理层！

  **用于处理连接网络的硬件部分，硬件上的范畴均在 链路层的作用范围之内**！包括硬件设备驱动、NIC（网卡）、光纤等物理部分，同时也包括 连接器 等一切传输媒介！

##### 五层模型

+ 在 OSI七层 与 TCP/IP 四层之间折中的分层模型！
+ 无论是 OSI七层 还是 TCP/IP四层 协议：发送数据时，在每个分层上，处理上一层传输的数据时，都会附加上当前层的协议首部信息，传递到下一层！在 接收数据时，每经过一层，都会剥离数据的首部信息，再将剥离后的数据传递给上一层！

#### 应用层

+ 为应用程序提供服务，并规定了 应用程序 通信相关的细节，也就是为 应用程序 规定了相关的通信协议！

##### HTTP 协议

```java
/*
 · HTTP （超文本传输协议）
 
 	HTTP 是浏览器和服务端之间的通信协议，是互联网上最为广泛的一种协议，所有的 WWW 文件都必须遵守这个协议标准！
 	
 	该协议所传输数据的主要格式是 HTML！
 	HTTP 是应用层协议，而 HTML 是表示层 数据协议！
*/
```

##### DNS

+ DNS（域名解析系统）

  是 因特网的 一项核心服务，它**是将 域名 和 IP 相互映射的一个分布式数据库**，能够方便用户通过域名 访问互联网，而不需要记住 IP数字串！

+ 域名*分层*

  域名具有层次结构，从上到下依次为：*根域名、一级域名、二级域名*

  ![](image\域名层次结构.png)

+ **DNS 将 域名 转换为 IP**

  ```
   · 首先，DNS 是分布式的，分布式体现在，每一层的域名，都有自己的域名服务器，并且下层的 域名服务器 都需要注册到所属的上层 域名服务器中！

   · 浏览器输入 url 之后，首先需要通过 DNS 域名服务器 根据域名 查询对应的 ip，再将请求发送给 指定的 ip 主机上！
  ```

  1. 首先查询 **浏览器缓存**；没有，则下一步！

  2. 查询**操作系统本地文件 /etc/hosts 中是否配置**；没有，则下一步！

  3. 查询 **本地DNS解析服务器 缓存**，如果查询不到，则直接将请求 转发到 **根域名服务器** 进行解析！

     ```
     LDNS 为 本地互联网接入 DNS 解析服务，具有缓存域名解析结果的功能！
     ```

  4. 根域名服务器(Root Server) 为 本地域名服务器(LDNS) 解析请求中的 **主域名服务器(gTLD)**，并将主域名服务器的 ip地址 返回给 本地域名解析服务器！

  5. 本地域名服务器 **向 主域名服务器发起解析请求**！

  6. 主域名服务器 解析请求中的域名，找到对应的 **Name Server域名服务器** ip 地址，并将其返回给 LDNS

     ```
     Name Server 域名服务器 中缓存了 域名和ip 的映射关系，正常情况下根据域名得到 目标IP 记录！
     ```

  7. LDNS 查询 Name Server 域名服务器，获取到 **域名&IP 映射关系**，并将其缓存到 LDNS 中！

  8. 最后，**访问 IP** ！

+ DNS 的传输层协议：

  DNS 可以使用 **UDP 或者 TCP** 进行传输，使用**端口号都为 53**

  + 使用 UDP

    *大多数情况下，DNS 使用 UDP 传输* 

    使用 UDP 传输时，要求 **域名解析器 和 域名服务器** 都必须要**自己处理 超时 和 重传** 来*保障传输的可靠性* ！

  + 使用 TCP（`如下两种情况之一，才会使用 TCP`）

    1. `如果返回的响应 超过 512 个字节`（因为 UDP 最大只支持 512 个字节）
    2. `区域传送`（区域传送是 主域名服务器 向 辅助域名服务器 传送变化的那部分数据）

#### 传输层

+ 为应用层提供了 通用的数据 传输服务，并且，还为高层应用 屏蔽了底层网络的通信细节，使得 通信过程看起来，像是在 通信双方的 传输层之间有一条 逻辑通信信道！

+ 传输层的两个数据传输协议：UDP（用户数据报协议）、TCP（传输控制协议）

  [JAVA 线上故障排查#网络部分](https://mp.weixin.qq.com/s/EM5tbVkG4KJZ2D95qjJNuA)

##### UDP

###### UDP

+ UDP（User Datagram Protocol）是一种**面向无连接**的通信协议。

+ 面向数据报，**尽最大可能交付数据**，且数据传输不可靠！

+ 缺点

  1. **数据传输不可靠**：

     *不会确认 对方是否 准备好接收数据，更不会确认，对方是否接收到了数据！如果传输途中，出现丢包问题，那么 UDP 也不会负责 重发！*

     如果需要可靠性传输，需要应用自己处理细节上的控制，例如：检测丢包、超时 等重传！

  2. **没有拥塞控制**：

     *不提供复杂的控制机制，即使是网络拥堵的情况下，UDP 也不会 通过流量控制 来缓解 网络阻塞！*

+ 优点

  1. 正是由于上述缺点，不需要主机维持复杂的链接状态，也不需要控制网络网络传输，使得 UDP **数据传输 简单高效**！
  2. 支持 **1 对 1、1 对 多、多 对 1、多 对 多** 数据通信！

+ 适用

  1. *数据报总量较少* 的通信，例如：DNS、SNMP等
  2. 视频、音频等多媒体 *及时通信* ！
  3. 现定于 LAN 等特定网络中的应用通信！
  4. *广播、多播* 通信！

###### UDP 首部格式

+ UDP 首部字段只有 8 个字节，包括 *源端口、目的端口、长度、校验和*；

  12 字节的 *伪首部* 是为了计算*校验和* 临时添加的！

  ![](image\UDP 首部格式.webp)

##### TCP

###### TCP

+ TCP（Transmission Control Protocol）是一种**面向连接**的通信服务！（报文段）

+ **基于 字节流 传输数据**：它将应用层传递的报文看成字节流，把字节流组织成大小不等的报文段，传递到下一层！

+ 优点

  1. **数据可靠性传输**

     通过 TCP 连接传送的数据，能*保证数据 无差错、不丢失、不重复 并且 按序到达* ！

     TCP 通过 **校验和、序列号、确认应答、重发控制、连接管理 以及 窗口控制 **等机制 实现可靠性传输！

  2. **支持 点对点（1 对 1）、全双工的通信**

     TCP 允许通信双方在连接过程中能够*同时传输数据* ！

  3. **拥塞控制、流量控制**！

+ 缺点
  1. 正是因为 TCP 连接双方需要保持连接状态，并且连接过程复杂，需要**占用较多的系统资源**！
  2. TCP **传输效率较低**

###### TCP 首部格式

<img src="image\TCP 首部格式.webp" style="zoom: 70%;" />

+ *源端口、目的端口*：确认通信方双方主机上的应用！

+ *序号*：对字节流进行编号！

  例如序号为 301 表示第一个字节的编号为 301，如果携带的字节流长度为 100，那么下一个报文段的序号应该为 401。

+ *确认号*：接收方期望接收的 下一个报文段的序号！

  例如：A 收到 B 的报文段，报文段的 序号为 100，所携带的 数据长度为 100 个字节，那么 A 期望下一次收到的 序号就是 200，因此 A 响应的报文段 中的 确认号 即为 200！

+ *数据偏移*：报文段中 数据部分 距离 报文段 起始处的 偏移量，实际上就是 首部字段的长度！

+ *确认 ACK*：TCP 规定，建立 TCP 连接后，所有传送的报文段都必须将 ACK 置 1。

  当 ACK = 1 时，确认号 字段有效，否则无效！

+ *同步 SYN*：建立连接时，用来同步序号！

  当 SYN=1 ACK =0 时表示这是一个 连接请求的报文段；若对方同意连接，则响应报文中 SYN =1 ACK=1！

+ *终止 FIN*：释放连接的标识！

  当 FIN =1，表示 该报文段的发送方，已经发送完数据，并要求释放连接！ 

+ *窗口*：窗口值表示 接收端 每次能接收数据的大小，避免发送端发送过多的数据，达到流量控制的效果！

  之所以要有这个 限制，是因为 接收方的数据缓存空间是有限的！

+ *RST 标志* ：RST 标志表示复位，用来异常地 关闭连接！

+ *校验和* ：检验首部 和 数据 两部分是否被修改！

##### TCP vs UDP

```java
/*
 1、TCP 面向连接，数据传输可靠；UDP 面向无连接，数据传输不可靠！
 2、TCP 有拥塞控制、流量控制等机制；UDP 没有复杂的控制机制，需要的话，只有在应用中实现这些控制细节！
 3、TCP 基于 字节流 传输；UDP 基于数据报传输！
 4、TCP 是 点对点，支持全双工通信；UDP 支持 1 对 1，1 对 多，多 对 1，多 对 多 通信！
 5、TCP 占用系统资源多，传输效率低；UDP 占用系统资源低，传输效率高！
 
 6、TCP 上层应用 一般传输 安全可靠数据，上层引用协议一般是：FTP、SMTP、HTTP
 	UDP 上层应用 一般是即时数据，并且数据量较小，上层协议一般是：DNS、SNMP
*/
```

##### TCP 连接管理

###### TCP 三次握手

<img src="image\TCP 三次握手.webp" style="zoom:67%;" />

+ 三次握手过程

  + 开始时，*服务端处于 LISTEN* 状态，等待客户端请求连接！

  1. *客户端* 请求连接：随后处于 *SYN_SENT* 状态，等待服务端响应

     A 向 B 发送 连接请求报文：**SYN=1（ACK =0）**

     并，发送一个初始**序号x**

  2. *服务端* 接收请求，如果同意连接，则返回 确认连接响应：随后处于 *SYN_RCVD* 状态，等待客户端响应

     B 向 A 发送 确认连接 响应报文：**SYN = 1 ，ACK =1**

     根据 A 请求中的 序号x，返回 **确认号 x+1** 

     并，发送一个初始 **序号y**

  3. *客户端* 收到确认连接响应后，对 服务端 再次进行确认响应：随后处于 *ESTABLISHED* 状态，表示已连接

     A 向 B 发送 响应报文：**ACK = 1**

     根据 B 响应中的 确认号 x+1，返回 **序号 x+1**

     根据 B 响应中的 序号y，返回 **确认号 y+1**

  + *服务端* 收到响应之后，处于 *ESTABLISHED* 状态，表示 已连接！

+ *为什么需要三次握手？*

  1. 三次握手的目的是**建立可靠的通信通道**，`让通信双方都能确认自己与对方的发送和接收功能都是正常的`！

     + 第一次握手

       *客户端 什么都不能确认* ！

       服务端能确认：*自己* 能正常接*收*，*对方* 能正常*发* 送！

     + 第二次握手

       客户端能确认：*自己* 的*收发* 正常！*对方* 的*收发* 正常！

       服务端确认了：*自己* 能正常接*收*，*对方* 能正常*发* 送！

     + 第三次握手

       客户端能确认：*自己* 的*收发* 正常！*对方* 的*收发* 正常！

       服务端确认了：*自己* 的*收发* 正常！*对方* 的*收发* 正常！

  2. 第三次握手的目的：除了服务端确认收发功能正常以外，还能**有效防止失效连接请求达到服务器，使得服务器错误打开连接**！

     客户端发送的连接请求 可能 在网络中 滞留，客户端等待一个超时重传的时间之后，就会重新请求连接，但是这个滞留的请求，始终是会到达服务端的，如果不进行第三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端就忽略服务器之后对滞留请求的连接确认，不进行第三次握手，因此就不会使服务端再次打开一个连接！

+ *为什么需要服务端回传 SYN？*

  ？？？ 服务端向客户端传回 SYN 是为了告诉 客户端，我接收到的信息就是你客户端发送给我的！

+ *传了 SYN，为什么还要传 ACK？*

  ？？？ 双方通信无误必须是两者互相发送消息都无误。传了 SYN，证明了 客户端到服务端的通道是没有问题的，但是，服务端到客户端的通道还需要使用 ACK 信号来确认！

###### TCP 四次挥手

​			<img src="image\TCP 四次挥手.webp" style="zoom:67%;" />

+ 四次挥手过程

  + 服务端 和 客户端*都处于 ESTABLISHED* 状态！

  1. 客户端数据发送完成之后，就会向 服务端 申请释放连接：*客户端* 进入 *FIN-WAIT-1* 状态，等待服务端确认！

     **FIN=1：表示 客户端数据已发送完毕，请求释放连接**！

     seq=u：TCP 规定 FIN 报文段，即时没有数据，也要消耗一个序号！

  2. 服务端接收到 连接释放请求，向客户端发出*确认* 报文：*服务端* 进入 *CLOSE-WAIT* 状态！

     ACK=1，ack=u+1，seq=v

     *客户端收到 确认报文，进入 FIN-WAIT-2 状态*，表示 客户端已经不再发送数据，只会接收 服务端发送的数据！

     -------------------------------------------------------------------------------------------------------------------------------------

     在此期间，服务端可以向客户端发送还未发送完毕的数据，而客户端只能接收数据，其发送功能已关闭！

     -----------------------------------------------------------------------------------------------------------------------------------------------------

  3. 服务端数据发送完毕之后，就会向 客户端 申请释放连接：*服务端* 进入 *LAST-ACK* 状态，等待客户端确认！

     **FIN=1：表示 服务端 数据已发送完毕，请求释放连接！**

     ACK=1，seq=w，ack=u+1

  4. 客户端接收到 连接释放请求，向 服务端发出*确认* 报文：*客户端* 进入 *TIME-WAIT 状态（等待 2MSL）* ！

     ACK=1，seq=u+1，ack=w+1

     *服务端收到请求后，立即进入 CLOSED 状态* ！

     *客户端 等待 2MSL* 之后，*自动进入 CLOSED 状态* ！ 

+ **为什么客户端要等待 2MSL？（TIME_WAIT）**

  ```java
  /*
   · MSL（Maximum Segment Lifetime）最长报文段寿命：报文段在网络上存活的最长时间，超过这个时间的报文段将会被丢失！

   · TTL（Time to live）
   	TTL 是 IP 首部字段，表示生存时间，这个生存时间是由源主机设置的初始置，但不是存在的具体时间，而是表示 一个IP数据报 可以经过的最大路由数目，每经过一个 路由，TTL 值-1，当 TTL为0 时，IP 数据报被丢失，同时会发送 ICMP 报文通知源主机！
  */
  ```

  1. **保证客户端发送的最后 ACK 能够达到服务器，防止 ACK 丢失 而 服务端无法接收 确认释放的情况！**

     对于 服务端 来说，在发送 FIN+ACK 报文请求释放连接之后，如果 客户端迟迟没有回应，就会认为 客户端没有收到 连接释放请求，于是 会再次发送一次！

     客户端等待 2MSL ，是为了能接收到 服务端重传释放请求，接着会回应报文，并重启 2MSL 计时器！

  2. 客户端在**等待的  2MSL 时间内，能够使得在本次连接中产生的所有报文段，都从网络中消失**，这样一来，如果有新的连接，就不会出现旧连接的报文段！

+ *为什么 建立连接时 三次握手，释放连接是 四次挥手？*

  因为连接过程中，服务端收到客户端的连接请求，就能立即回应客户端表示自己同意连接！

  在 释放连接过程中，服务端收到客户端释放连接申请之后，只能告诉你客户端，你可以单方面断开链接了，而我还有数据没有发完，等我发完了再告诉你我要断开了！等 服务端发送完数据之后，才会向客户端申请断开连接！

  可见，释放连接过程中，服务端断开连接和客户端断开连接并不是在同一条连接中阐明的，所以多了一次！

+ *如果已经建立了连接，但是客户端突然出现故障了怎么办？*

  TCP 有一个**保活计时器**，通常设置为 **2 小时**，如果两个小时内，没有手收到客户端的任何数据，服务器就会 **每隔75s 发送一个探测报文段**，**连续探测 10 次**之后，服务器就认为 客户端出现了故障，并**关闭连接**！

  服务器每收到一次客户端的请求，就会重新复位这个 计时器！

##### TCP 之 序列号

+ 每一次的 TCP 连接都应该 **互不相同**，并且需要 **随机生成**！

+ *互不相同*

  ```
   · 防止 上一次连接中 客户端发送的数据段在网络中滞留，当连接意外中断后，滞留的数据段在下一次连接中 被服务端接收的情况！

   · 假设：前后两次 TCP 连接中，初始序列号相同，都为 1
   	经过三次握手之后，序列号变为 3，如果客户端传送的 1个长度为 10 的数据段 在网络中滞留。由于网络原因 客户端、服务端意外断开，那么网络恢复后，双方重新建立连接，滞留在网络中的 数据段 也成功到达了服务端，由于数据段的序列号为 3，与服务端预期相同，因此被接收，而后续客户端发送的数据将无法正常被接收！
  ```

+ *随机生成*

  ```
   · 防止 序列号 被攻击者伪造！
  ```

##### TCP 之 SYN

###### SYN 标志位

+ 当 ack=0 时，syn 用于申请建立连接，用于 三次握手 的第一次握手！

+ **TCP 建立连接详情**

  ![](image\TCP 建立连接详情.jpg)

  + 如图，客户端发送 syn 请求连接后，服务端会响应 ACK+SYN 确认连接，并将 连接信息 存放在 **syns queue（半连接队列）** 中，表示等待客户端确认最终连接，而这些连接处于 SYN_RCVD 状态！
  + 当 服务端 接受到 ACK 确认应答之后，将该连接信息 从 syns queue 中移除，并加入 **accept queue（完全连接队列）** 中，进入ESTABLISH 状态！

  ```
  syns queue 和 accept queue 都是定长，因此，会出现 队列 溢出的状况！
  ```

  + [tcp 半连接队列 和 完全连接队列](https://www.jianshu.com/p/ff26312e67a9)

###### SYN Flood 攻击

+ **SYN Flood 攻击属于 DOS、DDOS 攻击中的 一种，它利用了 TCP 协议三次握手的缺陷，通过发送 大量的 半连接请求，耗费服务端的 CPU 和 内存资源！**

  ```
   · 配合 IP欺骗，SYN 攻击能够达到很好的效果，通常，客户端在短时间内伪造大量 IP，向服务端不断发送 syn 报文段申请连接，服务端响应确认报文段后，等待客户端确认！
   · 由于，IP 是伪造的，当这些 IP 的主机收到 ACK+SYN 报文段后，将会丢弃，此时服务端长时间接收不到确认信息（少了第三次握手），便会重传 ACK+SYN 多次（默认会重试 5 次）！
   	
   	因此，这种攻击会造成 服务端的半连接队列 被占满，同时，服务端会耗费资源响应 ACK+SYN，使得 服务端 运行缓慢，甚至系统瘫痪！
  ```

+ **防护措施**

  1. *无效连接监视释放* 

     ```
      · 不断监视系统中半连接 和 不活动连接，当达到一定阈值后，撤消这些连接，释放系统资源。
      · 这种方式，会导致 正常的连接也会被释放掉！
     ```

  2. *延缓 TCB 分配方法*

     ```
      · SYN FLOOD 攻击正是利用 服务端接收到 SYN 数据报文段之后，立即为其分配 TCB 资源，从而占用了系统资源！
      
      · 解决办法：
      	1. Syn Cache 技术：
      	收到 SYN 报文段之后，暂时将 连接保存到 HASH 表中，等待客户端确认应答后，再为其分配 TCB
      	
      	2. Syn Cookie 技术：
      	Syn Cookie技术则完全不使用任何存储资源，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源
     ```

  3. *使用 SYN Proxy 防火墙*

     ```
      · 对试图穿越的 SYN 请求进行验证之后才放行！
     ```

##### TCP 之 RST

###### RST 标志位

+ **RST 标志位：用来异常地关闭 无用的连接，区别于 四次挥手，在异常时代替 FIN**

  ```
   · 在发送 RST报文段 关闭连接时，直接丢弃缓冲区中的数据，并不会等待这些数据发送！
   	接收端收到 RST报文段 之后，不会发送 ACK 确认关闭连接！
  ```

+ *TCP 处理程序会在 自己认为的 异常时刻发送 RST报文！*

  如下几种情况：

  + *端口未监听*

    ```
    客户端向服务端发起连接时，如果 服务端 上并没有监听对应的 端口，则 服务端操作系统的 TCP 处理程序会发送 RST报文段！
    ```

  + *半开连接*

    ```
    如果在对方还未知的情况，私自断开连接，则该服务器处于 半开连接 状态，此后收到对方的数据之后，会响应一个 RST 报文段！

    对于 成功建立连接的两个服务器，客户端 向服务端发送 FIN报文 申请关闭连接， 服务端发送 ACK确认报文段 之后，如果网断了，那么 客户端 可能会放弃这个连接，而当 网 恢复之后，如果 服务端继续向 客户端 发送数据，此时，客户端并不认识这个连接，于是就会发送 RST 报文段！
    ```

  + *提前关闭连接*

    ```
    服务端 接收到 socket 发送的数据之后，如果数据没有成功的传送到 应用层，那么服务端将会发送一个 RST 提前关闭连接！
    ```

  + *在一个已关闭的 socket 上接收到数据* 

    ```
    若 通信双方 都都断开连接后，其中一方收到了 另一方发送的报文段，则会返回RST 报文段！
    ```

+ RST 产生的错误：

  1. connection reset

     ```
      · 在一个 已关闭的 连接上进行 读 操作！
     ```

  2. connection reset by peer

     ```
      · 在一个 已关闭的 连接上进行 写 操作！
     ```

  3. broken pipe

     ```
      · 管道层面的错误：表示对已关闭的管道进行 读写 操作，往往是在收到 RST，抛出 connection reset 错误之后，继续读写数据报的错！
     ```

###### RST 攻击

+ RST攻击 也称为 复位攻击。

  表示：**客户端和服务端通信的过程中，如果第三个服务器伪造 客户端的 TCP报文段，并发送给服务端，那么服务端将会发送一个 RST报文段，表示异常地断开与客户端的连接！**

+ *伪造的 TCP 报文段：*

  1. **伪造的 RST报文段**

     ```
      · 如果伪造 RST报文段，那毫无疑问，服务端会丢弃缓冲区上的所有数据，强制关闭连接！
     ```

  2. *伪造的 SYN报文段 ？*  *这个不是 第三次握手解决的问题嘛？和 RST 有关？ 百思不得其解*

     ```
      · 如果伪造 SYN 报文段，那么服务端认为 客户端疯了（与 OS 实现有关），正常连接时又来了新连接，此时 服务端会向 客户端 主动发送 RST 包，并在服务端强制关闭连接！
     ```

+ 伪造报文段 的*关键：* **源端口 & 序列号**

  + 一条 TCP 连接由 *源IP、目标IP、源端口、目标端口* 唯一确定！

  + 由于 目标端口 与 IP 公开，因此，想要伪造源主机上的 TCP 报文段时，只需要知道 源主机上正在通信的 端口即可！

  + 其次，即使成功获取了 源端口，如果伪造的 报文段 中，序列号 在服务端可接收的 序列号范围之外，那么该报文段会被服务端丢弃！

    因此，伪造报文段还需要 `伪造可行的 序列号`！

  > **疑问：源端口 和 序列号不能够抓包看到吗 ？ --- 自己尝试抓包看看！**

+ **为了防止 RST 攻击，需要在建立连接时使用随机的 序列号 ！**

  ```
   · RFC 793规定，应该使用一个 每4微妙 +1 的 32bit 数值计数器 来选定 序列号！
   	但是一旦有人掌握了 该计数器 的规律，那就能够轻易的伪造出 序列号，进而伪造 TCP 报文段！
   	
   · 因此，当前大部分操作系统 都会使用一种 半随机的方式生成 序列号，例如：Linux、Windows 便使用了 “计数器+随机偏移量” 的方式选取 序列号！
  ```

##### TCP 可靠传输

+ TCP 通过 **检验和、序列号与确认应答、超时重传、连接管理、窗口控制（流量控制）、拥塞控制 **等机制实现可靠性传输！

###### 检验和

+ TCP 首部中 有一个 *检验和* 字段，用于校验，首部 和 数据 在 接收端和发送端之间是否被修改，如果接收端检测到 检验和 不正确，则该 TCP 会被直接丢弃！

###### 确认应答 与 重传

+ 这涉及到 TCP 首部字段：序号、确认号

  *序号*：由发送端 发送给 接收端，表示当前数据段 的编号

  *确认号*：由 接收端 返回给 发送端，表示 确认发送端下一次发送的 数据端的编号！（已接收编号+数据长度）

+ **在 TCP 中，当发送端的数据达到 接收端后，接收端 会返回 发送端 一个已收到信息的通知，同时确认发送端下一次需要发送的 数据段，这就是 确认应答**，这个通知就是 确认号！

+ **发送端 在 一定时间内，若没有等到 接收端的 确认应答，就会认为 数据丢失，并重发数据！**

  *未收到 确认应答 的两种情况* ：

  1. *发送端 发送的数据 因为网络拥堵等原因 丢包* 了，接收端 无法接收到数据，此时 发送端 重传数据！
  2. 接收端 成功接收到 发送端 发送的数据，在 确认应答时，由于 网路阻塞等原因，*确认应答丢包了*，而 发送端无法接收到 确认应答信息，此时，发送端依旧会 重传数据！

+ 如果因为 确认应答 在网络中丢包，那么发送端重传的数据，在接收端就会重复！

  **接收端**正是**通过 序号 判断数据段是否重复**，如果数据重复，则接收端会抛弃（是否会应答？）

+ **发送端 多久会重发呢？**—— 超时时长的计算

  发送方 每次 发送数据时，都会计算 **往返的时间（RRT），以及往返时间的偏差值（抖动值）**，将 往返时间 与 其 偏差值 相加，则 重发超时的时长就是 比 这个总和 要稍稍大一点！

  重发超时计算 往返时间并考虑偏差值 是原因的：

  + *根据网络环境的不同，往返的时间 可能由大幅度的摇摆*，这是因为 数据段 是经过不同线路到达的，为了权衡这种环境，所以不仅需要考虑往返时间，还需要考虑 其偏差值！
  + 如果，往返时间偏差过大，那么这种计算方法就非常适合，避免了不必要的重传导致网络资源的消耗！

###### 连接管理

+ TCP 三次握手 与 四次挥手：保证连接可靠！
+ TCP 一次连接 与 断开，正常过程至少需要 来回发送 7 个包才能完成！

###### 滑动窗口

+ TCP 以 1 个段为单位，*每发一个段进行一次确认应答的处理，确认应答后才会发送下一个段* ！这就导致一个问题：**一次通信（包）往返的时间越长，网络的吞吐量就会越低**！滑动窗口 正是用于解决这个问题！
+ **滑动窗口**：发送端发送完一个数据段之后，不需要等待确认应答就能发送下一个段，*滑动窗口的大小，限定了 不需要接收确认应答就能发送下一个段的段总数量* ！（实际上，滑动窗口的大小，相当于并发送数据量）
+ 注意：滑动窗口机制需要使用大量的缓冲区，用于缓存还未收到确认应答的数据段！这是为了防止，网络传输中的丢包问题！发送端会根据接收端的确认应答信息，判断是否发生了丢包，如果出现丢包，那么，就可以使用缓冲区中的数据段进行重发！

+ >  重发机制 —— *高速重传机制* ！

  1. 数据段丢包

     ```java
     /*
      · 如果接收端 接收到一个 自己应该接受的序号 以外的数据，说明，自己下一步应该接收到的数据可能发生了丢包，于是 接收端会针对 到当前为止接收到的数据 返回确认应答！
      
      · 注意：即使接收端接收到的数据段并不连续，即，接收到的数据段，并不是自己当前应该接收的数据段，接收端也不会将其丢弃，而是放入缓冲区中！
      
      · 当发送端，连续 3 次收到同一个确认应答，就会将其所对应的数据，进行重发！
      
      	之所以要求 连续：是因为如果接收端一直没有接收到数据段，就会一直发送确认应答，如果 发送端收到的同一个确认应答，并不连续，中间穿插了其他的确认应答，那就说明，之前的数据已经安全到达接收端，并没有发生丢包！
      	
      	之所以要求 3次而不是 2次：是因为，即使 数据段的序号 被其他先到的数据段 替换了两次，也不会触发重发机制！因为网络原因，一些数据段的传输线路不同，使得后发送的数据段可能先到达，为了能尽量减少 数据段重发，节约网络资源，所以，可以多等2次！
     */
     ```

     ![](image\滑动窗口数据丢包.jpg)

  2. 确认应答丢包

     ```java
     /*
      · 接收端正常接收数据段，但是在确认应答时，发生丢包，此时数据是不需要重传的！因此，发送端并不是一定需要等待某个数据段的确认应答，才知晓该数据段被成功接收，还可以通过 发送端发送的下一个数据段确认应答，推测出，上一个数据段已经成功接收！
     */
     ```

     ![](image\滑动窗口重发：确认应答丢包.png)

+ *高速重传机制 vs 超时重传*

  + 超时重传：发送端 必须要收到 接收端 的确认应答，才会发送下一条数据！
  + 高速重发机制：发送端 不必等待 接收端的 确认应答，可以在 滑动窗口的限制下，继续发送下一条 数据段，并且，并不是一定需要收到 某个数据段的确认应答才能知晓该数据段被成功接收，允许确认应答丢包！
  + **高速重发机制：提高了网络的吞吐量，并且允许确认应答丢包，尽可能的避免了传输相同的数据，节约了网络资源！**

###### 流量控制

>  窗口问题1：一次性发送多个数据段，接收端 是否能 及时接收！

+ 流量控制 **用于 控制发送方 发送数据段 的速率**，保证接收方能正常接收数据！

+ TCP 首部的 **窗口字段**，该字段的值就是用来控制 发送端 发送数据段的 速率，该值**由 接收端主机设定，表示自己一次能够接收到的数据段数量**，*超过这个数据量的数据，将无法接收，会被丢弃* ！

+ 每一次发送数据段，*接收端除了应答响应以外，还会为 发送端设定窗口值*，使得发送端动态更新窗口的大小！当 确认应答响应中的 **窗口值为 0 时**，表示接收端处理达到上限，**发送端不能再发送数据** ！

  发送端*只有收到 接收端 的窗口更新通知后，才能继续发送数据* ！

+ 问题：

  如果接收端发送的 *窗口更新通知 丢包了怎么办？*

  为避免这类似的问题发生，发送端主机，会时不时的发送 **窗口探测** 的数据段，该数据段只含有 1 个字节，用于获取最新的窗口大小信息！

+ *窗口值 越大：网络吞吐量越高！*

+ **三次握手的过程中，两端都会设置自己所能够处理的 窗口值 大小。**

###### 拥塞控制

>  窗口问题2：如果在通信开始，就发送大量的数据，极有可能会导致整个网络拥堵，甚至瘫痪！

+ 拥塞控制 用于**避免 发送端 发送大量数据段 或者 发送端 发送速度太快 导致网络过载、拥堵甚至瘫痪** 的现象！

+ *拥塞控制的原理*

  TCP 维护了一个 **拥塞窗口 (cwnd)** 与 **慢开始门限 (ssthresh)** ，实现**逐渐增加发送量，谨慎探测网络可用宽带，直到发生重传**！

+ 拥塞控制机制：

  *慢开始、拥塞避免、快重传、快恢复*！

+ **慢开始、拥塞避免**

  *慢开始* ：通信开始，*cwnd 设置为 1*，发送数据时，会将 拥塞窗口（cwnd） 与 接收到的接收端通知的窗口大小 做对比，选择其中较小的窗口值，最为本次发送数据的上限！发送数据后，*每接收到一个 确认应答，拥塞窗口的值就会翻倍* ！

  *拥塞避免* ：当窗口值达到 慢开始门限（ssthressh）后，拥塞窗口的增速变为*每次+1*，避免窗口增速过快，导致网络承受不了！

  *当出现 超时重传，就需要 重新执行慢开始*，此时 ssthresh 设置为 拥塞窗口的一半（*ssthresh=cwnd/2*），而拥塞窗口大小 置1（*cwnd=1*）

+ **快重传、快恢复**

  *快重传*：就是滑动窗口中出现丢包时的数据段 高速重传机制。

  *快恢复*：当丢包情况，只涉及了 快重传，而还未触及超时重传时，说明网络拥塞不严重，此时就不需要重新执行慢开始，而是*重新设定慢开始门限*，使其为当前拥塞窗口的 一半（*ssthresh=cwnd/2*），并*重置拥塞窗口的大小*为慢开始门限的大小（*cwnd=ssthresh*），使其立即进入拥塞避免状态！

+ 慢开始 vs 快恢复

  慢开始 与 快恢复并不指窗口增速，而是指设置的初值！快恢复时说明网络拥塞不严重，此时，适当降低窗口大小，缓解网络压力，而没有必要将重新执行 慢开始，这反而会降低网络吞吐量！

  ![](image\拥塞控制.png)

##### TCP 粘包拆包 ？

#### 网络层

##### 概述

+ 网络层是整个互联网的核心！*使用 IP 协议*，可以实现世界上*任何两台计算机之间的点对点通信* ！

+ 网络层 只向上（传输层）提供`简单灵活的，无连接的，尽最大努力交付`的数据报传输服务。`不能保证可靠性传输，在分组交付的时限中，所传送的分组可能出错，丢失，重复和失序。通信的可靠性由传输层负责！`

+ 网络层 vs 传输层

  ```java
  /*
   · 网络层通过 IP 寻址和路由选择，在网络节点中找到中目标节点，实现节点之间的通信！
  	在网络层看来，通信就像是 两个终端节点之间 有一条通信信道！
   
   · 传输层通过 源端口 与 目标端口，在计算机节点的应用之间进行通信！
  	在传输层开来，通信就像是 两个终端节点上的应用之间 有一条通信信道！

   · 由上述可见，网络层 是为 传输层 服务的，只有经过 IP 寻址才能找到需要通信的终端节点，进而才能在节点的 应用之间进行通信！
   
   · 网络层向 传输层 提供 简单灵活的、无连接的、尽最大努力交付的数据传输服务！如果需要实现数据的可靠性传输，则需要 传输层 处理！传输层提供了一些列的数据可靠性机制！
   
   =》为什么不把 IP 设计成可靠性传输，从而将 这两种协议合并到一起呢？
   	答：
   	如果要一种协议规定所有的功能和作用，那么该协议的具体实时和编程就会变得非常复杂，无法轻易实现，相比之下，按照网络分层，明确定义每层协议的作用和职责之后，针对每层具体的协议进行编程会更加有利于协议的实现与管理。
   	网络通信中如果能够进行有效分层，就可以明确TCP 与 IP 各自协议的最终目的，也有利于后续对这这些协议进行扩展和性能上的优化，分层也简化了每个协议的具体实现！
  */
  ```

##### IP（IPv4）

###### IP 数据数据报格式

<img src="image\IP数据报格式.webp" style="zoom:67%;" />

+ *版本* ：**4（IPv4）**、6（IPv6）

  上述 IP 数据报格式为 IPv4 的格式，所以版本为 4，IPv6 数据报格式与这个格式不同，不过首部的前 4 个自己都是版本标识！

+ **首部长度** ：表示 IP 首部的大小！

  占用 4 位 ，*以 4 字节为一个单位*，因此 _IP 首部最大为 15 * 4=60 字节_！

  如上图：IP 首部固定部分占用 20 个字节！如果可选字段不足 4 个字节，则填充补全！

  综上：IP 首部_最小为 5 * 4=20 个字节_，最大为 15 * 4=60 个字节！

+ *区分服务* ：用于表明服务质量，一般不使用！

+ *总长度* ：表示 IP 首部 和 数据部分 的总字节数！

  占 16 位，*以 1 字节为一个单位*，因此 IP 数据报最大长度为 2^16 个字节！

+ **生存时间（TTL）**

  指可以中转的路由器的数量，每经过一个 路由器，**TTL -1，直到变为 0 则该包被丢弃**！

  **用于防止 无法交付的数据报 在网络中无限传播！**

+ *协议* ：表示 IP 数据报中的数据应该交由上层的哪个协议处理，例如：ICMP、TCP、UDP等

+ **首部检验和**：*只校验数据报的首部*，不校验数据部分！用于确保 IP 数据报不被破坏！

  数据报 每经过一个 路由器 都会重新计算校验和，因此，不校验数据部分，可以减少计算量！

+ **源地址、目标地址** ：通信双方的 IP 地址（4 个字节）

  ---

  IP 首部中的 *标识、标志、片偏移*  三个字段表示**分片重组**！

  ---

+ *标识* ：用于（数据报过长）分片重组，同一个数据报的分片标识相同，不同数据报的分片标识不同！

+ *标志* ：表示分片的信息

+ *片偏移* ：用来表示被分片的每个分段相对于原始数据的位置，第一个分片的对应值为0！以 8个字节 为单位！

  ![](image\IP 分片.webp)

  ---

###### IP 地址编址方式

+ IP 占 32 位，在计算机内部使用 二进制方式处理，*32 位IP 地址以每 8 位为一组，分成 4 组，每组以 "."  分隔* ！

+ IP 地址并非根据主机台数来配置，而是 主机上的网卡（NIC），每个 NIC 都至少设置一个 IP 地址！

+ 由两部分组成：网络标识（网络地址）+主机标识（主机地址）

  > IP 地址 ::= { < 网络号 >,  < 主机号 > }

  ```java
  /*
  	【？？？？？？？？？？？？】
   · 网络号：在数据链路层的每个段配置不同的值，网络号必须要保证相互连接的每个段的地址不相互重复！在相同段内相连的主机必须有相同的网络地址
   · 主机号：不允许在同一个网段内重复出现！

   ·网络标识 与 主机标识 使IP 地址具有唯一性！

   · 利用 目标IP地址 进行路由，即使不看主机标识，通过网络标识就能判断出是否为该网段内的主机！
   	与操作：本段网络号 & 目标主机网络号
  */
  ```

+ IP 编址的方式经历了三个阶段：*分类、子网划分、无分类*

+ **分类**

  <img src="image\IP 分类.webp" style="zoom:50%;" />

  + A 类

    ```java
    /*
     · A 类 IP 地址首位为 "0"
     · 第 1~7 位是网络标识：0.0.0.0 ~ 127.0.0.0
     · 后 24 位，表示 主机标识。
     	因此该 A 类的一个网段内，最多容纳 主机标识 2^24-2 个！
    */
    ```

  + B 类

    ```java
    /*
     · B 类 IP 地址前两位为 "10"
     · 第 2~15 位是网络标识：128.0.0.0 ~ 191.255.0.0
     · 后 16 位，表示 主机标识。
     	因此 B 类的一个网段中，最多容纳 主机标识 2^16-2 个！
    */
    ```

  + C 类

    ```java
    /*
     · C 类 IP 地址前三位为 "110"
     · 第 3~23 位是网络标识：192.0.0.0 ~ 223.255.225.0
     · 后 8 位，表示 主机标识。
     	因此 B 类的一个网段中，最多容纳 主机标识 2^8-2 个！
    */
    ```

  + D 类
    + D 类地址前四位为 "1110"
    + 剩下的 28 位，表示 网络标识，D 类地址没有 主机标识，常用于 多播

  - E 类：前四位 为 ”1111“，还未使用！

  ```java
  /*
  【注意】
  	分配 主机标识 时，不能全为 1 ，也不能全为 0：因此上述网段内可容纳的主机标识都需要 -2
  	
  	主机标识 全为0：表示 网络地址 或者 不可获知的 IP地址
  	主机标识 全为1：通常作为 广播地址
  	
  */
  ```

+ **子网划分**

  + 对于A、B、C 类的IP 地址划分，在实际网络架构中，往往不会有  几万 甚至 几千万个 网络节点 在 同一个链路上连接，因此，同一个网段内往往不会有理想中那么多的网络节点存在，这就造成了 IP地址 的浪费！

    —— 于是出现 子网划分！

  + 子网掩码的出现，使得 IP地址 不再受限制于 固定的类别划分（A、B、C等），而是可以在 某一类别上，用子网掩码自由地扩展 网络标识 的长度！细分出 更小粒度的网络！

  + 通过在 主机号 中那一部分作为子网号，将 IP地址 划分为 三级IP地址？？？

  + 引入 子网之后，一个 IP 地址便有两种 地址识别码：IP 地址 、子网掩码

    > IP 地址 ::= { < 网络号 > , < 子网号 > , < 主机号 > }

    ```java
    /*
     · A 类地址默认的 子网掩码 255.0.0.0
     · B 类地址默认的 子网掩码 255.255.0.0
     · C 类地址默认的 子网掩码 255.255.255.0
    */
    ```

  + 注意：外部网络看不到子网的存在！

  + 表示方式

    ```java
    /*
     · 子网掩码 占用 32 位！
     · 网络标识（包括扩展后的网络标识部分）全为 1，主机标识部分 全为 0
     	子网掩码必须是 首位开始连续的 1，后面为 连续的 0
    */

    /*
     · 示例：假定 B类 IP 地址（172.20.100.53）定义了 10 为子网掩码，则表示前前 26 位表示网络标识（原为前 16 位）
     
     · 表示方式1：
     	IP 地址：		172.	20.		100.	52
     	子网掩码：	  225.	  255.   255.   192		
     	
     	网络地址：    172.	  20.   100.   0
     	子网掩码：	  225.	  255.   255.   192		
     	 
     	广播地址：    172.	  20.   100.   63
     	子网掩码：	  225.	  255.   255.   192		
    */
    ```

+ **无分类编址 CIDR**

  无分类编址 CIDR 消除传统 A 类、B 类、C 类地址以及划分子网的概念，而是采用 任意长度分割 IP地址 的 网络标识和 主机号！

  > IP 地址 ::= { < 网络前缀 > , < 主机号 > }

  CIDR 记法上采用 在 IP 地址后面加上网络前缀长度的方法

  ```java
  /*
   ·示例：假定 IP 地址：172.20.100.53 前 26 位表示网络标识

   · 表示方式：
   	IP 地址：		172.	 20.	100.	52 /26
   	网络地址：    172.	  20.   100.   0  /26 
   	广播地址：    172.	  20.   100.   63 /26
  */
  ```

  CIDR 地址掩码 依旧称为 子网掩码！

  一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量，把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也成为 ”超网“。

  路由表 记录了  ”网络前缀“ 和 ”下一跳地址“ 映射关系，在查找时，可能会得到不止一个匹配结果，应当采取最长前缀匹配来确定应该匹配哪一个！

##### ARP 协议

###### 介绍

+ 网络层 实现了 主机之间的通信，而数据链路层实现的是 每段链路上的通信！在通信过程中，IP 数据报的源地址 和 目的地址始终不变，而 MAC 地址会随着 链路的 改变而改变！

  ![](image\链路地址 MAC 变化.webp)

+ *ARP 是一种地址解析的协议。以 目标IP 地址为线索，用来定位下一个应该接收到数据报的网络节点的 MAC 地址！*

+ 每个 主机都有一个 ARP 高速缓存，用于存放 本局域网上的各个**网络节点（主机、路由器）的 IP — MAC 的映射表**，称为 **ARP 表**。

###### ARP 工作过程

+ 主机 A 向主机 B 发送数据报！

1. 主机 A 从 主机 B 的 IP地址中，获取网络号，将其与 主机A 自己的 网络号 做**与( & )运算**，判断 A、B 是否在同一个网段内！

   >  情况1：A 、B **在**同一个局域网内（同一个网段内 / 同一条链路内）

   1. 主机 A 查询自己的 ARP 表，确定是否有 B 的 IP-MAC 映射表项！

      如果找到映射表项，则通过 MAC 地址，将 IP 数据报 发送给 主机B

   2. 如果 ARP表中没有 B 的映射项，则以广播的形式发送一个 ARP 请求报文，请求报文中包括了 A 的 IP 和 MAC 地址，以及 B 的 IP 和 全0 的 MAC地址！

      该网段中的所有 网络节点都会收到这个 ARP 请求，当 B 收到之后，发现是发送给自己的，就将自己的 IP 和 MAC 地址响应给主机 A！并将 A 的 IP-MAC 存入自己的 ARP表中！

   3. A 收到响应之后，便将 B 的 IP-MAC 存入 ARP 表中！并向 B 发送数据！

   >  情况2：A 、B **不在**同一个局域网内（同一个网段内 / 同一条链路内）：通过网关转发（路由器转发）

   1. 主机 A 查询自己的  ARP表，确定是否有 网关IP-网关MAC 映射表项！

      如果找到了，则通过 MAC 地址，将 IP 数据报 发送给 网关！

   2. 如果 ARP表 中没有 网关IP-网关MAC 映射，则依旧以广播的形式发送 ARP 请求报文！

      获得到网关 MAC 地址后，A 便将网关的 IP-MAC 存入自己的 ARP 表中，并将 IP数据报 发送给网关！

   3. 网关会根据自身的 路由表，自动找到 需要发送的下一个 节点（B 主机 或者是 路由器）！

      ```
      网友如是说：
      	A网关收到数据包后查看，根据目的IP（B的IP地址）查找路由表，找到通往目的网段的路由及下一跳，得到下一跳的MAC地址（ARP获得的），然后将数据包中原IP、目的IP保持不变，原MAC地址换成A网关的MAC地址，目的地址换成下一跳的MAC地址，转发到下一跳的设备（路由器，三层交换机等）。
      	如果下一跳就是B的网关（不是B的网关，就重复上面的动作），网关收到后查看，发现目的IP在自己的内部（ARP表），将数据包中原IP、目的IP保持不变，原MAC地址换成B网关的MAC地址，目的地址换成B的MAC地址，将数据包发给B，B得到数据包后，完成A与B的通信。 
      	
      一跳：
      	一跳（1 Hop）是指利用数据链路层以下分层的功能传输数据帧的一个区间！
      	以太网等数据链路中使用 MAC 地址传输数据帧，此时一跳是指从 源MAC 地址到目标 MAC 地址之间传输帧的区间！

      多跳路由：
      	是指，路由器或者主机 在转发IP数据报时，只指定下一个路由器合作和主机，而不是将到最终目标地址为止的所有通路全都指定出来！因为每一个区间再转发IP数据报时会分别指定下一个跳的操作，直至包达到最终的目标地址！
      ```

###### ARP 相关问题

+ 能否只是用 MAC 或者 IP？

  ```
  IP 是网络层的 寻址，用于在 链路网中查询 目标主机！
  MAC 是数据链路层网络节点之间的寻址！同一个网段内，可以使用 MAC 寻址，不网段，则需要通过 路由转发！

  抽象出来网络层，就是要为上层屏蔽底层网络的通信细节，由于底层网络通信复杂，如果给出硬件地址MAC地址，那么不仅用户体验不好，还会增加许多麻烦！
  ```

##### ICMP

###### 介绍

+ ICMP 网际控制报文协议

  ICMP 协议 辅助 IP协议 ，用于检测**网络通信故障** 并 **实现链路追踪**，最典型的应用就是 **PING 和 traceroute**！

  ICMP 封装在 IP 数据报中，但是不属于高层协议！

+ ICMP 报文格式 

  <img src="image\ICMP 报文格式.webp" style="zoom: 67%;" />

+ ICMP 报文类型

   可分为 **差错报告报文** 和 **询问报文**

  <img src="image\ICMP 报文类型.webp" style="zoom:67%;" />

  1. 终点不可达（ICMP 目标不可达消息）

     IP 路由器无法将 IP 数据报 发送给目标地址时，会给 发送端主机 返回一个目标不可达的ICMP消息，并在消息中显示不可达的具体原因！

     ```
     	如上述 ARP 工作过程：如果 A、B主机不在同一个网段内，则 IP数据报 会经过各个 路由器 转发到 B！
     	如果 各个路由表中都就没有 B 主机的信息(B 不存在) 或者 B 主机没有连接到网络（B 下线），那么 将会向 A 主机发送 ICMP 信息，表示 B 主机不可达，此时不可达的原因是 Host Unreachable
     ```

  2. 改变路由（ICMP 重定向消息）

     ```
     	如果路由器发现 发送端主机 使用了次优先级的路径发送数据时，即路由器发现 当前路由路径并不是最合适的时候，那么它会返回一个 ICMP 重定向消息，消息中包含了最适合的路由信息 和 源数据！主机接收到之后，会将路由信息 存入自己的 路由表中，下次使用！
     	这种方案一般不使用，因为如果 收到的路由信息不正确时，那么 ICMP 有可能无法正常工作！
     ```

  3. 时间超时（ICMP 超时消息）

     IP 包中有一个 字段 TTL( Time To Live) 表示 IP数据报 的生存时长，每经过 一个路由器就会 -1，当值为 0 时这个 IP 数据报就会被丢弃，此时 IP 路由器会给 源主机 发送一个 ICMP的超时信息，通知源主机 该数据报已经被抛弃！

     ```
     设置 TTL 的主要原因：
     	避免 无用的 IP数据报 在网络上无休止的被转发！同时还能用 TTL 控制数据报被转发的范围！
     ```

     典型应用：**traceroute**

  4. 回送请求 / 回送应答（ICMP 回送消息）

     用于判断发送的数据报 是否已经成功达到 目标主机！

     可以向 目标主机 发送回送请求的消息，也可以接收 目标主机 发送的 回送应答消息！

     典型应用 ：**PING**

###### ICMP 应用

+ **Traceroute —— TTL**

  ```xml
  <!--
  	Traceroute 利用 TTL 为零时，接收到数据报的 网络节点，就会向源主机发送 ICMP超时信息 的特性，发送探测报文跟踪通信过程的 链路信息！

  	Traceroute 发送的 IP数据报 封装的是，无法交付的 UDP 用户数据报！当目标主机时，由于主机无法接收，则会返回一个 ICMP 终点不可达的消息！Traceroute 正是以此作为标志，判断数据报是否达到目的主机！

  	1、Traceroute 以增量式TTL 的方式不断的向目的主机发送探测报文！
  	2、起始 TTL 设置为1，可通过 数据报所到的第一个路由器 发送的 ICMP TTL报文判断该路由器的 IP地址！
  	3、而后，每获得一个 每发送一个探测报文就将 该报文的 TTL+1，直到 探测报文到达 目标主机！
  	  目标主机返回的 ICMP 目标不可达 消息便能提醒 源主机 已经探测到 目标主机了！
  	
  这个过程中，通过增量式TTL 返回的 ICMP TTL 消息，就会知道两个主机之间的 路由器IP！
  -->
  ```

  [Traceroute 原理实现](https://www.cnblogs.com/lcword/p/9862539.html)

  命令

  ​	UNIX下：traceroute 目标主机IP地址

  ​	windows 下：tracert 目标主机IP地址

+ PING —— Echo

  ```xml
  <!--
  	PING 命令：主要用来测试 两台主机之间的 连通性！
  	
  	原理：PING 命令 通过向 目标主机 发送 ICMP Echo 回送请求，目标主机 接收到 Echo 请求报文之后，会发送 Echo 回送应答。PING 会根据回送应答的时间 和 响应的次数评估出数据报往返的时间 以及 丢包率！
  -->
  ```

  命令：ping 目标主机IP


##### 路由器

+ 路由器 是 工作在 *网络层* 的设备，在网络层面上，连接两个网络，并*对分组报文进行转发* ！
+ 路由器 是 根据 IP地址 转发的！
+ 内部维护的是**路由表**，用于记录 **网络地址（网段地址）**与 **下一跳路由器IP 地址 **的映射关系！

#### 数据链路层

##### 介绍

+ 由于 网络层提供的是 主机之间的数据传输服务，而主机之间，可能有许多链路，此时就需要链路层协议 **为 同一条链路上的网络节点 提供数据传输服务**！它将来自网络层的 IP 数据报封装成 帧，以**帧**为单位传输！

  数据链路层的主要作用是在互联网 同一个数据链路的节点之间进行数据传递，而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据传递！

+ 数据链路层的协议 定义了 通过通信媒介互连的设备之间传输的规范！

  通信媒介包括 双缆线、同轴电缆、光纤、电波 以及 红外线等介质（各个设备之间 有时也会通过 交换机、网桥、中继器 等中转数据）

##### 帧格式

+ 数据链路层 为 网络层传递的*IP数据报*，添加 *首部*  和 *尾部* ：用于标记 帧的开始和结束！

  ![](image\帧格式.webp)

##### MAC 地址

+ MAC 地址是**链路层的地址**，用于**唯一标识网络适配器（NIC、网卡）**

  一个主机拥有多少个网络适配器就有多少个 MAC 地址！

  例如：笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有 两个 MAC 地址！

##### 网络

+ *网络拓扑* ：*总线型、环形、星型* 。然后实际的网络都是这些简单的拓扑结构`错综复杂的组合`而成的！

+ 从通信介质上来看，网络可分为 共享介质型 和 非共享介质型！

  1. 共享介质型网络

     ```
     是指 由多个设备共享一个通信介质的一种网络！

     在这种方式下，设备之间使用同一个载波信道进行发送和接收，所以，基本上采用半双工通信！

     早期的以太网、FDDI 就是共享介质型网络！
     ```

  2. 非共享介质网络

     ```
     是指 不共享通信介质，是对 介质采取专用的一种传输控制方式！

     在这种方式下，网络中的每个计算机 直连 交换机，由交换机 负责转发数据帧。发送端与接收端并不共享通信介质，因此很多情况下采用 全双工通信 方式！

     ATM 就是采用 这种传输控制方式！

     非共享介质方式 可以根据 交换机的高级特性 构建虚拟局域网（VLAN）、进行流量控制等！		
     ```

##### 以太网

###### 介绍

+ **以太网** 是 一种典型的 **星型拓扑结构局域网**！
+ 早期使用 集线器进行连接，使用的是半双工通信！现在 **以太网使用 交换机的技术**，配合双绞线电缆，实现了**全双工**的通信方式！

###### 以太网 帧格式

![](image\以太网帧格式.webp)

+ *目的 MAC 地址、源 MAC 地址*

+ *类型*：标记上层应用使用的协议

+ *IP 数据报*

+ **FCS**：**帧检验序列**，使用的是 CRC 检验方法！

  检测 帧 在传输过程中是否被损坏！

###### 通信方式

+ 半双工

  ```
  为什么半双工？
  	早期的以太网 采用 CSMA/CD 传输控制方式，首先要判断是否可以进行通信，如果可以就独占通信介质发送数据，因此不能同时接收和发送数据 —— 半双工通信！
  ```

  ![](image\CSMA 半双工.jpg)

+ 全双工

  ```
  为什么全双工？
  	以太网 采用 交换机与双绞线电缆（或者光纤电缆）的情况下，既可以通过交换机的端口 与 计算机之间进行一对一的连接，也可以通过相连电缆内部的收发线路，分别进行接收和发送数据，因此交换机的端口与计算机之间可以实现同时收发的全双工通信！
  ```

  ![](image\交换机全双工.jpg)

###### 交换机

+ 交换机：是一种**链路层**设备，*主机直连到 交换机的端口上，使得数据的收发互不干扰* ，可实现全双工通信！

+ 以太网交换机：*持有多个端口的* **网桥**！

  ```
   · 以太网 利用了 非共享介质型 网路中的 交换机技术 将集线器或集中器等设备以星型连接，形成了 交换集线器，也称为 以太网交换机！
   
   · 以太网交换机构建网络，使得计算机与交换机端口之间形成一对一的连接，因此，发送端与接受端之间并不共享通信介质，可以实现全双工！
  ```

+ 交换机 **转发表**

  交换机中有一个 **目标MAC** 与 **转发接口** 的**映射表，称转发表**！

  *发送数据时，交换机根据 数据链路层 中每个帧的 目标MAC 地址，查询转发表，决定发送数据的接口！*

+ **交换机 学习过程**

  转发表 不需要使用者 在每个终端 或 交换机 上手工设置，而是可以**自动生成**。

  ```xml
  <!--
   · 最开始 转发表是空的！
   · 交换机 接收到 主机A 的数据帧时，会将 主机A 的 MAC 地址，与接收数据的端口，建立映射关系，存入转发表中！ 同时 交换机会检查 转发表中 是否存在 目标MAC 地址 与 接口的映射，如果有，则从该接口发送！
   · 如果没有，则交换机从各个接口广播数据帧！此时，只有目标主机才会接收这个 数据帧，其他会将器抛弃！
   · 目标主机 向主机 A 回应时，经过交换机，交换机会将 数据帧转发给主机A，同时将 主机B 与对应接口关联，存入 转发表中！
     正是由于 交换机的自学能力，使得交换机是一种即插即用的设备，而不需要网络管理员手动设置交换表的内容！
  -->
  ```


#### 物理层

##### 介绍

+ 在 网桥或交换集线器（交换器） 等 物理设备 或 数据链路层数据报转发设备中，不需要设置IP地址。因为这些设备只负责将 IP 数据报转化为 01比特流转发或对数据链路帧的数据部分进行转发，而不需要应对 IP 协议
+ *计算机是以 二进制 0、1 表示信息，然后实际的通信媒介之间的处理的都是 电压的高低、光的闪灭 以及 电波的强弱等信号，将这些信号转换为 0、1 二进制流正是 物理层的工作* ！

##### 集线器 / 中继器

  ```
集线器 是 在物理层面上延长网络的设备，相当于一个 再生信号放大器！
集线器是一种物理层设备，作于与 比特流，而不是数据帧！
它将 电缆  中传递的 电信号/光信号 经过波形调整放大后再传递给另一个电缆！从而扩大网络储传输的距离！
  ```
+ 一般情况下，集线器 两端的 通信媒介相同，并且不能再传输速度不同的媒介之间转发！

+ 如果集线器同时收到两个不同接口的帧，那么就会发生碰撞！

#### ARP表 / 路由表 / 转发表

##### ARP 表

+ 协议层：网络层

+ 拥有者：主机、路由器

+ 作用

  网络层的两个主机之间进行数据通信，最终是要交给 下一层 数据链路层 进行数据交互！而数据链路层 以 MAC 地址作为主机唯一标识，所以，网络层通过 IP 查询主机 实际上是通过 IP 查询主机所在的网段，最终通信是由 MAC 地址完成的！

  同一个网段内的主机之间，通过 MAC 地址通信，此时，就需要在 网络层维护一个 ARP表，建立 **主机IP** 与 **主机MAC 地址**的**映射关系**！

  通信时，查询 ARP表，就能获取 目标主机的 MAC 地址，完成通信！

##### 路由表

+ 协议层：网络层

+ 拥有者：路由器

+ 作用

  网络层中两个主机 可能会处于不同的网段！此时，就需要通过 路由器 转发数据！

  路由器维护了一个 路由表，用于记录 **网络地址（网段地址）** 与 **对应的路由器IP地址（下一跳地址）** 之间的映射！

  路由器接收了 IP 数据报之后，解析数据报，查看目标地址：

  	如果与自己是同网段，那就查看ARP表，如果`ARP表不存在就广播` ！

  	如果 不是 同一个网段，路由器会查询 路由表，找到对应网段的下一跳路由器IP地址，并将数据转发！如果，**路由表中有多项网段匹配，则采用最长前缀的那个**！如果**找不到，那就丢弃**！

##### 转发表

+ 协议层：数据链路层

+ 拥有者：交换机

+ 作用

  同网段的主机之间通信，需要知道 MAC 地址，此时，MAC 地址就是用于在链路层完成主机之间的通信！

  交换机是一个多端口的网桥，每一个端口与主机直连，主机之间 就是 通过交换 完成数据通信的！

  交换机中维护了一个 转发表，用于建立 **源主机MAC 地址**  与 **为该主机服务的端口** 之间的**映射**！

  当 主机A 向主机 B 发送数据帧时，交换机，会查询转发表中 是否存在 主机B 的MAC 地址与 端口的映射，如果有，则直接从该端口转发数据，如果没有，交换机会 泛洪 转发数据帧，这个数据帧只有 目标主机才能接收并处理，无关主机将会将其丢弃，主机B 收到数据帧之后，向主机A 应答，通过 交换机时，交换机就会将 主机B 的MAC 地址与 端口建立映射关系，保存起来，并将数据转发给 主机A —— 这就是 交换机的工作原理，也是交换机的**学习过程**！