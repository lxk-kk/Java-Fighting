#### 线程_基础

#####  volatile

```java
/*
volatile 是一个Java中的一个关键字，被修饰的变量具有 可见性和有序性 等两个重要特性！

【可见性】volatile 保证 某一个线程对变量的修改，其他所有线程都可见：内存屏障和禁止重排序优化来实现可见性
	1、任何线程对变量的修改，都是对线程内部的工作内存中的 变量副本修改，volatile 关键字能够保证 线程对变量的修改被强制同步到 JMM 的主存中！【原理】对 volatile 修饰的变量 进行写操作时，JVM 会在写操作之后加入一条 store 指令屏障，将本地共享变量刷新到主存中！
	2、任何线程对变量的读取，一般而言是从线程的工作内存中获取，而 volatile 关键字能够保证 强制线程从主存中获取变量的值，而非使用副本！【原理】对 volatile 修饰的变量 进行读操作时，JVM 会在读操作前加入一条 load 屏障指令，从主存中读取共享变量的值！

注意：synchronized 和 lock 都能保证可见性 ———— 加锁、解锁 ：开销大！
	线程加锁前：将清空工作内存的中的共享变量副本，从而使用共享变量变量时，需要从主存中重新读取新的值！
	线程解锁前：必须将共享变量的最新值刷新到主存中！


【有序性】volatile 保证 JVM在优化程序指令时，不会对指令进行重排序：禁止指令重排序！
	java 内存模型允许 编译器和处理器 对指令优化处理、重新排序，但是重排序过程不会影响到单线程程序的执行，而是会影响到多线程程序执行的正确性！
	JVM 在 “先行发生原则” 下能够保证自然有序，不通过任何手段解能保证指令的有序性！当两个指令操作无法从 happends-before 中推导出来时，JVM 将对它们进行优化排序！

注意：synchronized 和 lock 都能保证有序性 ———— 加锁、解锁 ：开销大！
	加锁 可以保证锁内的代码块单线程执行，相当于顺寻执行同步代码，所以也能保证有序性！
	
【总结】
1、volatile 具备可见性和有序性！
2、volatile 线程不安全，不具备原子性，它只能保证共享变量在各个线程之间的可见性，如果两个线程同时从主存中获取了 volatile 修饰的共享变量的值，则这两个线程可以同时对 该变量进行修改，但是由于两个线程都不会从主存中再次读取值，所以相互之间不知道对方对共享变量的操作，依旧是线程不安全的！

有关 JMM 与 volatile 细节详见：[ m-Java_volatile 与 JMM .md ]
*/
```

##### volatile 与 synchronized 区别

```java
/*
volatile 与 synchronized 没有什么关系！
1、volatile 用于修饰变量、属性；synchronized 用于修饰方法、代码块
2、volatile 保证变量的的修改读取对其他线程可见，也变量的执行指令不被重排序，但它并不能保证并发情况下，变量的修改是线程安全的，不能实现同步操作；synchronized 表示同步代码块，能够实现 作用域内的操作是原子操作！
*/
```

final

static

