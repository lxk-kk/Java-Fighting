#### 【线程_基础】

##### 进程 VS 线程

```java
/*
 · 进程
 	进程是 具有独立功能的程序 关于某个数据集合上的 一次运行活动，是系统进行资源分配的基本单位！在 Java 中，通过执行 main方法，就能启动一个进程！
 · 线程
 	线程是比进程更小的运行单位，是进程中的一个运行实体，可以视为轻量级的进程，是 CPU调度 的基本单位！
 	上述，通过 main方法 能启动一个进程，而执行 main方法 的正是这个进程中的主线程！
 
 · 进程与线程的区别：
 	· 进程是资源分配的基本单位，是资源的拥有者；
	  线程是CPU调度的基本单位，与资源分配无关，它不拥有资源，只使用所属进程的资源！
	· 进程之间相互独立，不能共享资源；（各个进程都有自己独立的虚拟地址空间）
 	  线程属于某个线程，并与进程内的其他线程 共享 进程的资源！（进程内的所有线程共享进程的虚拟地址空间）
 	· 线程的切换开销比进程小！
 	    进程的切换涉及到有关资源指针的保存，以及地址空间的变化等问题！
 	    线程切换时，由于同一进程中的线程共享资源和地址空间，将不涉及资源信息的保存和地址空间的变化！
 	· 线程通信比进程之间的通信更加方便！
 
 · JVM 角度看待进程与线程之间的关系：
 	· 线程是进程划分成的更小的运行单位，线程与进程最大的不同在于各个进程之间相互独立，而同一个同一个进程内的线程则可以相互影响，多个线程共享进程的 堆和方法区（jdk1.8 及之后的元空间）资源，而每个线程之间又存在私有的程序计数器、虚拟机栈和本地方法栈！
 
 【拓展】
 => 为什么 程序计数器是线程私有的？
 	答：为了使线程切换之后能恢复到正确的执行位置！
 	程序计数器是当前线程所执行的字节码的行号指示器，字节码指示器工作时就是通过改变这个计数器值来选取下一条需要执行的字节码指令！
 	由于java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式实现的，在任何一个确定时刻，一个处理器（内核）只会执行一条线程中的指令。因此为了使线程切换之后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器！
  
 => 虚拟机栈 和 本地方法栈 为什么线程私有？
 	答：为保证线程中的局部变量不被其他线程访问到！
  	· 虚拟机栈：虚拟机栈描述的是 java 方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程！
  	· 本地方法栈：本地方法栈发挥的作用和虚拟机栈类似，区别在于：虚拟机栈为 虚拟机执行 java 方法（也就是字节码）服务，而本地方法栈为 虚拟机使用到的本地方法（Native方法）服务！
    · 综上：为保证线程中的局部变量不被其他线程访问到，虚拟机栈和本地方法栈都是线程私有！
 
 => 堆和方法区（元空间）
 	堆和方法区是所有线程共享的资源！
 	Java堆 是虚拟机所管理的最大的一块内存，主要用于存放对象实例（所有的对象实例都会在这里分配内存）（jdk1.7 时，HotSpot 将永久代的 字符串常量池、静态变量等移到了堆中！）
 	方法区主要用于存储被虚拟机加载的 类型信息、常量、静态变量、即时编译器编译后的代码缓存 等数据。（JDK1.7时，HotSpot 将方法区中的 字符串常量池、静态变量移除，jdk1.8 时 将剩余内容全部移到元空间中）！
 	
*/
```

##### 并发 VS 并行

+ 并发：同一时间段内，宏观上，多个任务同时执行，而在单个CPU核心上，单位时间内，多个任务交替执行！
+ 并行：单位时间内，多个任务，在多个CPU核心上同时执行！

##### 为什么使用多线程

```java
/*
 1、
 	在单核时代，多线程主要用于提高CPU和IO设备之间的综合利用率，这是因为程序在进行IO操作时，不需要使用到CPU，此时CPU就空闲出来了，多线程下，就能将CPU利用起来！
 	在多核时代，多线程下能实现并行计算，并行运行程序，提供CPU的利用率，而单线程只会使用到其中的一个核心！
 2、
 	单线程下所有操作都是串行执行，对于一个包含了多个服务的复杂业务来说，响应缓慢。
 	多线程下，支持异步执行任务，可以将不同的服务交由不同的线程完成，整个业务操作并发执行，大大缩短响应时间！
 3、
 	互联网时代，现在的系统都需要支持并发的访问，这是单线程不可企及的！利用好多线程机制，可以大大提高系统整体的并发能力，改善系统性能！
*/
```

##### 多线程可能带来的问题

+ 并发编程的目的就是为了提高程序执行的效率，但也同时会遇到很多问题，例如：`上下文切换、死锁、内存泄漏以及受限于硬件和软件的资源闲置等问题！`

##### 上下文切换

+ 上下文切换：

  多线程编程中，CPU通过为每个线程分配时间片来实现并发任务执行，当某个线程执行完一个时间片后，便将CPU执行权交给下一个线程！对于某个任务，CPU通过时间片分配的算法来循环执行，当任务执行完一个时间片后，就会切换到下一个任务，但是，在切换任务之间，CPU会保存当前任务的执行状态，以便下次切换回该任务时能够再次加载任务的状态。`任务从保存到再加载的过程就是一次上下文切换！`

+ 上下文切换耗时：

  时间片是CPU分配给各个线程的，为了使多个线程宏观上同时执行，所以时间片会非常短，所以 CPU 需要不停的切换线程执行，时间片一般是几十毫秒（ms）

+ 如何减少上下文切换？

  1. `无锁并发编程`

     多线程争抢锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁。

     例如：将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同短段的数据！

  2. `CAS 算法`

     Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁！

  3. `使用最少线程`

     避免创建不需要的线程，如果任务较少，但是创建了很多线程来处理，这样会造成大量的线程都处于等待状态！

  4. `协程`

     在单线程里实现多任务调度，并在单线程中维持多个任务之间的切换！

##### 死锁

###### 死锁介绍

```java
/*
 · 死锁
 	两个或者多个进程相互请求对方所持有的资源，若无外力作用，它们将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁！（操作系统中的定义：系统中两个或者多个进程无限期地等待永远不会发生的条件，系统将处于停止状态，这种现象称为进程死锁，这一组进程称为死锁进程）
 
 · 死锁具备的四个条件
 	1、资源互斥：一个资源每次只能给一个进程使用！
 	2、不可剥夺条件：进程持有的资源，不可被其他进程强行剥夺，只有自己使用完毕才会释放资源
 	3、请求与保持：一个进程因请求资源而阻塞时，对已获取的资源保持占有！
 	4、循环等待：进程之间形成环状的资源等待关系！
*/

/**
 * 死锁示例
 * @author 10652
 */
public class DeadLockTest {
    private static Object resource1 = new Object();
    private static Object resource2 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            // 资源1
            synchronized (resource1) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource2");
                // 持有资源1 请求资源2
                synchronized (resource2) {
                    System.out.println(threadId + " : request resource2 successfully");
                }
            }
        }).start();
        new Thread(() -> {
            // 资源2
            synchronized (resource2) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource1");
                // 持有资源2 请求资源1
                synchronized (resource1) {
                    System.out.println(threadId + " : request resource1 successfully");
                }
            }
        }).start();
    }
}
// 输出结果：
current thread 13
13 : hold the resource1
current thread 14
14 : hold the resource2
13 : try request the resource2
14 : try request the resource1
```

###### 死锁检测工具

1. jConsole 工具

   ```java
   /*
    · idea命令行 》jConsole
   
    · jConsole 工具
    	jConsole 是 JDK 自带的监控工具，用于连接正在运行的本地或者远程 JVM，对运行在 Java 应用程序的资源消耗和性能进行监控，并通过可视化界面的方式展现！
     · 如下图：检测上述程序的死锁！
   */
   ```

   ![](image\死锁_1.png)

   ![](image\死锁_2.png)

2. jstack

   ```java
   /*
    · idea 命令行 》jstack 进程ID
   
    · jstack 是虚拟机自带的一种堆栈跟踪工具，用于打印给定的 java进程ID 或者 core file 或者 远程调试服务的 java堆栈信息！
    
    · jstack 工具可以用于生成 java虚拟机当前时刻的线程快照。
      线程快照是当前 java虚拟机 内每一条线程正在执行的方法堆栈的集合，生成线程快照主要是为了定位线程出现长时间停顿的原因！例如：线程间死锁、死循环、请求外部资源导致的长时间等待等！
      线程停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在做什么，或者在等待什么资源！
     · 如下图：检测上述死锁进程程序：
   */
   ```

   <img src="image\死锁_3.png" style="zoom: 67%;" />

###### 解决死锁

1. 死锁预防

   ```java
   /*
   【程序运行前：预防】：破坏死锁的四个条件之一！
   
    · 破坏 不可剥夺条件 ：主动释放资源
    	当进程请求资源没有得到满足时，必须释放已持有的资源，需要时再次获取！
   
    · 破坏 请求与保持条件 ：全部获取
    	在进程运行前，一次性申请所需要的全部资源，且当该进程申请去的资源能得到满足时，才给予一次性分配！
   
    · 破坏 循环等待条件 ：统一顺序获取资源
    	为每个资源编号，定义资源的线性顺序，请求资源的线程必须统一按照编号递增/递减的顺序获取！
    	
    · 【注意】：资源互斥条件（例外）：不可被破坏：临界资源本来就是需要互持访问的！
   */
   ```

2. 死锁的避免

   ```java
   /*
    【程序运行时：避免】
    · 在程序运行过程中，对进程发出的资源申请进行动态检测，判断分配资源后系统是否可能产生死锁！
    · 典型的算法：银行家算法
   */
   ```

3. 死锁的检测

   ```java
   /*
    进程 - 资源分配图（有向图）：判断是否有死锁发生！
   */
   ```

4. 死锁的解除

   ```java
   /*
    1、资源剥夺法
    	当发现死锁后，从其他线程数剥夺足够的资源给死锁进程，以解除死锁状态！
    2、撤销进程法
    	发现死锁后，撤销所有的死锁进程！
   */
   ```

   

