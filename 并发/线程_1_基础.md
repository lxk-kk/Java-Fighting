#### 【线程_基础】

##### 进程 VS 线程

```java
/*
 · 进程
 	进程是 具有独立功能的程序 在某个数据集合上的 一次运行活动，是系统进行资源分配的基本单位！在 Java 中，通过执行 main方法，就能启动一个进程！
 · 线程
 	线程是比进程更小的运行单位，是进程中的一个运行实体，可以视为轻量级的进程，是 CPU调度 的基本单位！
 	上述，通过 main方法 能启动一个进程，而执行 main方法 的正是这个进程中的主线程！
 
 · 进程与线程的区别：
 	· 进程是资源分配的基本单位，是资源的拥有者；
	  线程是CPU调度的基本单位，与资源分配无关，它不拥有资源，只使用所属进程的资源！
	· 进程之间相互独立，不能共享资源；（各个进程都有自己独立的虚拟地址空间）
 	  线程属于某个线程，并与进程内的其他线程 共享 进程的资源！（进程内的所有线程共享进程的虚拟地址空间）
 	· 线程的切换开销比进程小！
 	  进程的切换涉及到有关资源指针的保存，以及地址空间的变化等问题！
 	  线程切换时，由于同一进程中的线程共享资源和地址空间，就不涉及资源信息的保存和地址空间的变化！
 	
 	· 线程通信比进程之间的通信更加方便！
 
 · JVM 角度看待进程与线程之间的关系：
 	· 线程是进程划分成的更小的运行单位，线程与进程最大的不同在于各个进程之间相互独立，而同一个进程内的线程则可以相互影响，多个线程共享进程的 堆和方法区（jdk1.8 及之后的元空间）资源，而每个线程之间又存在私有的程序计数器、虚拟机栈和本地方法栈！
*/
```

##### 并发 VS 并行

+ 并发：同一时间段内，宏观上，多个任务同时执行，而在单个CPU核心上，单位时间内，多个任务交替执行！
+ 并行：单位时间内，多个任务，在多个CPU核心上同时执行！

##### 为什么使用多线程

```java
/*
 1、
 	在单核时代，多线程主要用于提高CPU和IO设备之间的综合利用率，这是因为程序在进行IO操作时，不需要使用到CPU，此时CPU就空闲出来了，多线程下，就能将CPU利用起来！
 	在多核时代，多线程下能实现并行计算，并行运行程序，提供CPU的利用率，而单线程只会使用到其中的一个核心！
 2、
 	单线程下所有操作都是串行执行，对于一个包含了多个服务的复杂业务来说，响应缓慢。
 	多线程下，支持异步执行任务，可以将不同的服务交由不同的线程完成，整个业务操作并发执行，大大缩短响应时间！
 3、
 	互联网时代，现在的系统都需要支持并发的访问，这是单线程不可企及的！利用好多线程机制，可以大大提高系统整体的并发能力，改善系统性能！
*/
```

##### 多线程可能带来的问题

+ 并发编程的目的就是为了提高程序执行的效率 与 系统利用率，但也同时会遇到很多问题，例如：`上下文切换、死锁、内存泄漏以及受限于硬件和软件的资源闲置等问题！`

##### 上下文切换

+ 上下文切换：

  多线程编程中，CPU通过为每个线程分配时间片来实现并发任务执行，当某个线程执行完一个时间片后，便将CPU执行权交给下一个线程！对于某个任务，CPU通过时间片分配的算法来循环执行，当任务执行完一个时间片后，就会切换到下一个任务，但是，在切换任务之间，CPU会保存当前任务的执行状态，以便下次切换回该任务时能够再次加载任务的状态。`任务从保存到再加载的过程就是一次上下文切换！`

+ 上下文切换耗时：

  时间片是CPU分配给各个线程的，为了使多个线程宏观上同时执行，所以时间片会非常短，所以 CPU 需要不停的切换线程执行，时间片一般是几十毫秒（ms）

+ 如何减少上下文切换？

  1. `无锁并发编程`

     多线程争抢锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁。

     例如：将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同分段的数据！

  2. `CAS 算法`

     Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁！

  3. `使用最少线程`

     避免创建不需要的线程，如果任务较少，但是创建了很多线程来处理，这样会造成大量的线程都处于等待状态！

  4. `协程`

     在单线程里实现多任务调度，并在单线程中维持多个任务之间的切换！

##### 死锁

###### 死锁介绍

```java
/*
 · 死锁
 	两个或多个进程相互请求对方所持有的资源，若无外力作用，它们将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁！
 	（操作系统中的定义：系统中两个或者多个进程无限期地等待永远不会发生的条件，系统将处于停止状态，这种现象称为进程死锁，这一组进程称为死锁进程）
 
 · 死锁具备的四个条件
 	1、资源互斥：一个资源每次只能给一个进程使用！
 	2、不可剥夺条件：进程持有的资源，不可被其他进程强行剥夺，只有自己使用完毕才会释放资源
 	3、请求与保持：一个进程因请求资源而阻塞时，对已获取的资源保持占有！
 	4、循环等待：进程之间形成环状的资源等待关系！
*/

/**
 * 死锁示例
 * @author 10652
 */
public class DeadLockTest {
    private static Object resource1 = new Object();
    private static Object resource2 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            // 资源1
            synchronized (resource1) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource2");
                // 持有资源1 请求资源2
                synchronized (resource2) {
                    System.out.println(threadId + " : request resource2 successfully");
                }
            }
        }).start();
        new Thread(() -> {
            // 资源2
            synchronized (resource2) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource1");
                // 持有资源2 请求资源1
                synchronized (resource1) {
                    System.out.println(threadId + " : request resource1 successfully");
                }
            }
        }).start();
    }
}
// 输出结果：
current thread 13
13 : hold the resource1
current thread 14
14 : hold the resource2
13 : try request the resource2
14 : try request the resource1
```

###### 死锁检测工具

1. jConsole 工具

   ```java
   /*
    · idea命令行 》jConsole
   
    · jConsole 工具
    	jConsole 是 JDK 自带的监控工具，用于连接正在运行的本地或者远程 JVM，对运行在 Java 应用程序的资源消耗和性能进行监控，并通过可视化界面的方式展现！
     · 如下图：检测上述程序的死锁！
   */
   ```

   ![](image\死锁_1.png)

   ![](image\死锁_2.png)

2. jstack

   ```java
   /*
    · idea 命令行 》jstack 进程ID
   
    · jstack 是虚拟机自带的一种堆栈跟踪工具，用于打印给定的 java进程ID 或者 core file 或者 远程调试服务的 java堆栈信息！
    
    · jstack 工具可以用于生成 java虚拟机当前时刻的线程快照。
      线程快照是当前 java虚拟机 内每一条线程正在执行的方法堆栈的集合，生成线程快照主要是为了定位线程出现长时间停顿的原因！例如：线程间死锁、死循环、请求外部资源导致的长时间等待等！
      线程停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在做什么，或者在等待什么资源！
     · 如下图：检测上述死锁进程程序：
   */
   ```

   <img src="image\死锁_3.png" style="zoom: 67%;" />

###### 解决死锁

1. 死锁预防

   ```java
   /*
   【程序运行前：预防】：破坏死锁的四个条件之一！
   
    · 破坏 不可剥夺条件 ：主动释放资源
    	当进程请求资源没有得到满足时，必须释放已持有的资源，需要时再次获取！
   
    · 破坏 请求与保持条件 ：全部获取
    	在进程运行前，一次性申请所需要的全部资源，且当该进程申请去的资源能得到满足时，才给予一次性分配！
   
    · 破坏 循环等待条件 ：统一顺序获取资源
    	为每个资源编号，定义资源的线性顺序，请求资源的线程必须统一按照编号递增/递减的顺序获取！
    	
    · 【注意】：资源互斥条件（例外）：不可被破坏：临界资源本来就是需要互持访问的！
   */
   ```

2. 死锁的避免

   ```java
   /*
    【程序运行时：避免】
    · 在程序运行过程中，对进程发出的资源申请进行动态检测，判断分配资源后系统是否可能产生死锁！
    · 典型的算法：银行家算法
   */
   ```

3. 死锁的检测

   ```java
   /*
    进程 - 资源分配图（有向图）：判断是否有死锁发生！
    MySQL 中也使用了 资源分配图检测死锁，不过稍有不同！
   */
   ```

4. 死锁的解除

   ```java
   /*
    1、资源剥夺法
    	当发现死锁后，从其他线程数剥夺足够的资源给死锁进程，以解除死锁状态！
    2、撤销进程法
    	发现死锁后，撤销所有的死锁进程！
   */
   ```

   

