### 【Redis_2_基础】

#### Redis 键

##### 键空间

+ Redis 是一个`键值对（key-value） 数据库服务器`，保存了数据库中所有键值对的结构就是 `数据库的键空间`！

  redis 底层使用 redisDb 结构体表示 数据库， redisDb 用字典（dict ）保存了数据库中所有的 键值对 ，这个字典就是 数据库的 **键空间**`（key space）`！

  ```c
  typedef struct redisDb{
      // ... 
      // 字典结构：表示数据库键空间，保存着数据库中所有的键值对！
      dict *dict;
      // ... 
  }redisDb;
  ```

+ 键空间 和 用户所见的数据库是直接对应的！

  + 键空间的键 就是 数据库的键（key），每个键都是一个`字符串`类型！
  + 键空间的值 就是 数据库的值（value），每个值 可以是 `字符串（String）、列表（List）、哈希表（Hash）、集合（Set）、有序集合（Sorted Set）`等类型中的任意一种！

+ 键空间操作

  set（添加新键 \ 更新旧键）

  del（删除指定键：实际上是删除键空间中 键所对应的 键值对 对象）

  get（对指定的 键取值：实际上就是在键空间中取出对应的值对象，根据值对象的类型不同，具体取法也不同）

  flushdb（清空数据库：删除键空间中所有的 键值对）

  randomkey（随即返回数据库中的某个键：在键空间中随即返回一个键）

  exists、rename、keys 等都是通过对键空间进行操作实现的！

+ 读键空间时的维护工作：`并不是单纯的执行用户请求`

  + 访问一个键后，会更新 数据库的键空间 命中（hit） / 不命中（miss） 次数
  + 访问一个键后，服务器会更新键的 LRU（最后一次使用时间）
  + 访问键时，如果已过期，则先删除这个键，再执行其他操作
  + 如果由 客户端 watch 监视了 某个键，则 服务器对键修改后，会将键标记为脏（dirty）数据，令 事务程序 能注意到这个键已被修改！
  + 服务器没次修改 一个键之后，对会将 脏（dirt）键计数器+1，这个计数器会触发 服务器的持久化及复制操作！
  + 如果服务器开启了数据库通知功能，则对键修改后，服务器将按配置通知相应的数据库！

##### 键的生存时间 / 过期时间

+ 生存时长

  *expire、pexpire*：以 秒/毫秒 级别，为键设置 生存时长！

+ 过期时间

  *expireat、pexpireat*：以 秒/毫秒 级别，为键设置 过期时间！

+ *TTL、PTTL*

  参数：设置了 生存时长 / 过期时间的 key！

  返回：以 秒/毫秒 级别 返回 `距离这个键被服务器自动删除还剩的时长`！

+ 注意：expire、pexpire、expireat：最终都转换为 pexpireat 指令实现！

+ 底层实现：**过期字典**

  上述 数据库结构体 redisDb，除了维护 键空间，还维护了一个 过期字典！

  ```c
  typedef struct redisDb{
      // ... 
      // 键空间
      dict *dict;
      // 过期字典
      dict *expires
      // ... 
  }redisDb;
  ```

  `过期字典的键 是一个指针：指向键空间中的某个 键对象（即是 某个数据库键）`

  `过期字典的值 是一个 long long 类型的整数：上述键对象的过期时间（毫秒级精度 的 UNIX时间戳）`

+ 移除过期时间

  *persist*：移除一个键的过期时间，是 pexpireat 的反命令！

  persist 指令 在过期字典中查找指定的键，并解除 过期字典中 `键和值（即：键和过期时间）`的关联！

+ 过期键判定

  1、 通过 过期字典

  ​			1）检查给定的键是否存在于 过期字典中：存在，则获取过期时间

  ​			2）检查当前 UNIX 时间戳是否大于 过期时间：yes，则键过期；no，则未过期

  2、 通过 TTL / PTTL 指令

  ​			对某个键执行 TTL / PTTL 命令，若返回值 >= 0，则键未过期！

  注意：`Redis 中采用的是 第一种方法：通过过期字典判断，因为 直接访问字段，比执行一个命令稍微快一点！`

##### 过期键的删除策略

​		  上述已经设定了键的 过期时间 / 生存时长，并且可以判断键是否过期，现在就是该决定过期的键如何删除的问题！

###### 三种过期删除策略

1. 定时删除

   在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键过期时间时立即执行对键的删除操作

   ```c
   /*
    · 优点
    	定时删除是对内存友好的：通过使用定时器，定时删除策略，可以保证过期键会尽可能被删除，并释放过期键所占用的空间！
    
    · 缺点
    	1、 对 CPU时间 不友好。
    		在过期键比较多的情况下，删除过期键的行为 可能会占用相当一部分 CPU 时间，这在内存不紧张但是 CPU 时间紧张的情况下，将 CPU时间用在 删除和当前任务无关的过期键上，无疑是对服务器的响应的时间 和 吞吐量 造成影响！
    	
    	2、 除此之外，创建一个定时器需要用到 Redis 服务器中的时间事件，而当前时间事件 的实现方式为 —— 无序链表，查找一个事件的需要 O(N) 的时间复杂读，这并不能高效的处理大量的时间事件！
   */
   ```

2. 惰性删除

   放任过期键不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；否则返回该键。

   ```c
   /*
    · 优点
    	对 CPU时间 友好：程序只会在访问键的时候才会对键做过期检查，这可以保证 CPU不用 时刻关注所有的过期键是否过期，而是关注客户端请求，并且删除键时，不会涉及到当前无用的键，使得 CPU 不会在与当前无关的键上耗费时间！
    
    · 缺点
   	对 内存不友好：如果一个键 已经过期，而这个键仍然保留在数据库中，只要这个过期键不被删除，它所占用的内存空间就不会被回收！
   	如果数据库中由非常多的过期键，而这些过期键恰好没有被访问到，那么他们永远也不会被删除（除非用户手动指定 flushdb 命令）—— 这是一种内存泄漏的现象。
   	对 运行状态依赖于内存的 redis 服务器来说是非常不友好的！
   */
   ```

3. 定期删除

   每隔一段时间，程序就会对数据库进行一次检查，删除里面的过期键！至于删除多少过期键，以及要检查多少个数据库，由算法决定！

   ```c
   /*
    · 定期删除策略是 定时删除 与 惰性删除 的折中方案！
    		定时删除占用大量的 CPU时间，影响服务器的响应时间和吞吐量！
    		惰性删除占用大量的 内存，造成 内存泄漏！
    		
    ·
    	定期删除每隔一段时间执行一次删除过期键操作，并通过限制 删除操作执行的时长 和 频率 来减少删除操作对CPU时间的影响！
    	定期删除过期键，能有效地减少 因过期键而带来的内存浪费！
    
    · 何理决定！
    	定期删除 执行时间太长 / 太频繁 —— 回退到 定时删除
      定期删除 执行时间太短 / 太少  —— 回退到 惰性删除
   */
   ```

###### Redis 采用的策略

+ redis 采用 惰性删除 + 定期删除 配合的删除策略！

  服务器能在 合理使用 CPU 时间 与 避免浪费内存空间的之间取得平衡！

+ 惰性删除：访问的时候检查

+ 定期删除

  1. 每次定期删除函数执行时，都会从 一定数量的 数据库中取出一定数量的随机键进行检查，并删除其中的过期键！
  2. redis 会维护一个变量 记录当前检查的进度（检查到哪个数据库），当 定期删除函数 再次被调用时，可以接着上一次的进度继续处理
  3. 随着 定期删除函数的不断执行，服务器中的所有数据库都会被检查一遍，然后进行新一轮检查工作！

###### Redis 过期键策略的弊端

+ *极端问题：*

  由上述来看，定期删除 只会选取部分数据库，并且 随机选择 数据库中的部分过期键进行检查，在极端状态下，当 被设置了过期时长的键越来越多，很可能有一大部分 过期键 未被检测到并且也不曾被使用，而此时服务器 内存空间被占满，这仍然是内存泄漏的问题！

+ **解决：使用 内存淘汰机制！**

  1. **noeviction**（默认策略）
  2. **volatile-ttl**
  3. **allkeys-lru**
  4. **volatile-lru**
  5. **allkeys-lfu**
  6. **volatile-lfu**
  7. **allkeys-random**
  8. **volatile-random**

+ *【补充 —— 手写 lru】*

  ```java
  // LinkedHashMap 已经实现了 LRU  
  
  /*
   · 实现1
   	当容量超过 100 时，开始执行 LRU：将最少未使用的 TimeoutInfoHolder 对象 evict 掉
  */
  final Map<Long,TimeoutInfoHolder> timoutInfoHandlers = 
      Collections.synchronizedMap(new LinkedHashMap<Long,TimeoutInfoHolder>(100,.75f,true)){
      @Override
      protected boolean removeEldestEntry(Map.Entry eldest){
          return size()>100;
      }
  }
  
  /*
   · 实现2
  */
  
  class LRUHandler<K,V> extends LinkedHashMap<K,V>{
      private int cacheSize;
      /**
       * 设置最大缓存
       */
      public LRUHandler(int cacheSize){
          // true 表示让 LinkedHashMap 按照访问顺序进行排序，最近访问的放在头部，最老访问的放在尾部 
          super((int)Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
          this.cacheSize=cacheSize;
      }
      @Override
      protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
          // 当 map 中的数据量大于 指定的缓存个数的时候就自动删除最老的数据！ 
          return size()>cacheSize;
      }
  }
  ```

##### AOF、RDB、复制等对过期键的处理

###### AOF

1. AOF 文件写入

   当 redis 以 AOF持久化模式执行时，数据库中某个已经过期，但是还没有被 惰性删除 或 定期删除 的键，不会影响到 AOF文件！当这个过期键被惰性删除 或者 定期删除之后，程序会向 AOF 追加一条 *DEL 命令*，显示记录该键已经被删除！

2. AOF文件重写

   在 AOF 文件重写时，程序会对数据库中的键进行检查，已经过期的键不会被保存到 重写后的文件中！

###### RDB

1. 生成 RDB 文件

   在执行 SABE / BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会保存到新创建的 RDB 文件中！

2. 载入 RDB 文件

   在启动 redis 服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：

   * 如果 服务器 以主服务器模式运行：载入 RDB 文件时，程序会对 文件中保存的键进行检查，已过期的键将不会被载入数据库！
   * 如果 服务器 以从服务器模式运行：载入 RDB 文件时，无论是否过期，文件中所有的键都会被载入到数据库中！但是，主从服务器进行数据同步时，从服务器的数据库就会被清空。所以，一般来讲，过期键也不会对 从服务器 造成影响！

###### 复制

+ 当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制！

  + 主服务器 删除一个过期键之后，会显式的向所有从服务器发送一个 DEL 命令，告知从服务器删除该键！
  + 从服务器只有接收到主服务器发送的 DEL 命令，才会删除过期键！在这之前，遇到过期键，就按照过期键的处理方式处理，不会主动删除！

+ 通过由主服务器控制从服务器统一删除 过期键，可以保证主从服务器的数据一致性！

  所以：一个过期键在主服务器中存在时，在从服务器中也存在复制品！



#### Redis 文件事件

##### 文件事件处理器

+ Redis 基于 Reactor 模式开发了自己的 网络事件处理器：**文件事件处理器**（file event handler）

+ 文件事件处理器由*套接字、I/O多路复用程序、文件事件分派器（dispatcher）、事件处理器* 等四部分组成！

  ![](image\文件事件处理器组成.png)

+ 文件事件处理器 在单线程的模式下，通过 `IO多路复用技术`，监听多个套接字，实现了高性能的网络通信模型！

+ 文件事件处理器的工作流程：

  1.  文件事件处理器 使用 IO多路复用程序 监听 并发的`套接字`请求，并根据套接字所要执行的任务，为套接字关联相应的`事件处理器`!

  2. 被监听的 套接字 在执行`连接（accept）、读取（read）、写入（write）、关闭（close）`等操作前，会根据操作 生成对应 `文件事件`。

  3. 所有已生成 文件事件的`套接字`都将存放到一个队列中！通过队列，以串行的方式 将`套接字`传送给 文件事件分派器。

     ![](image\套接字队列.png)

  4. 文件事件分派器 接收到 IO多路复用程序传来的`套接字`，并根据套接字的事件类型，调用`已关联的事件处理器`进行处理。

     *【注意】*当上一个`套接字`的文件事件被处理完毕之后（即，与`套接字`关联的事件处理器执行完毕），I/O 多路复用程序才会继续向文件事件分派器传送下一个`套接字`！

##### I/O 多路复用程序

+ Redis 的 I/O多路复用 采用了 select、epoll、evport、kqueue 等多路复用技术，对于 Linux平台来说，默认采用的是 epoll 技术，它能将 网络IO 耗时降到最低，使得单个线程能高效地处理 并发的 socket请求！

  *多路：多个网络连接（多个 Socket 连接），复用：指复用同一个线程处理请求。*

  [redis 与 io 多路复用](https://blog.csdn.net/chennieg27434/article/details/100841252?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
  
  [epoll：底层原理](https://www.jianshu.com/p/e6b9481ca754)

##### 事件处理器

+ 4 种处理器

  1. 连接应答理器

     ​	为了对客户端进行应答，服务器要 为监听套接字 关联 连接应答处理器！

  2. 命令请求处理器

     ​	为了接受客户端的命令请求，服务器要为客户端套接字 关联 命令请求处理器！

  3. 命令回复处理器

     ​	为了向客户端返回命令的执行结果，服务器要为客户端套接字 关联 命令回复处理器！

  4. 复制处理器

     ​	当主服务器 和 从服务器进行复制操作时，主从服务器都需要 关联 为复制功能特别编写的 复制处理器！

+ 与客户端 jsocket 通信

  *连接应答处理器、命令请求处理器、命令回复处理器* 共同实现一次 通信过程：

  ![](image\通信过程.png)

#### Redis Pipline

###### 往返时延

+ 客户端 与 Redis服务器 使用 TCP协议连接之后，不论是 客户端向 Redis 发送命令，还是 服务端向客户端返回命令的执行结果，都需要进行网络传输，这两个部分 网络传输的总耗时称为*往返时延* 。

+ 根据网络性能的不同，往返时延 也不同，大致来说，到本地回环地址的往返时延，在数量级上相当于 Redis 处理一条简单的命令（如：PUSH list 1 2 3）的时间。

+ 同一个客户端 连续执行多条命令时，不论命令之间是否存在依赖，都需要等待 上一条命令执行完毕，收到返回结果后，才能执行下一条命令！这多条命令累计的往返时延对 间接地 降低了 redis 的吞吐量！

  ![](image\往返时延示例.png)

###### Pipline 管道

+ Redis 底层通信协议对 **管道（pipline）**提供了支持。

+ 通过管道 可以*一次性发送多条命令，并在所有命令执行完毕后，一次行将结果返回*！

+ 当一组命令中的*每条命令都不依赖 之前命令的执行结果* 时，就可以将这组命令通过 管道（pipline）一起发出。管道通过减少客户端与 Redis 的通信次数来实现**降低 往返时延累计值**的目的！

  ![](image\pipline.png)