### 【Redis_补充】

#### Redis 发布 / 订阅

###### 概述

+ Redis 的发布订阅功能由 **PUBLISH、SUBSCRIBE、PSUBSCRIBE** 等命令实现！
+ 取消订阅由 **UNSUBSCRIBE、PUNSUBSCRIBE** 命令实现！

###### 订阅

+ SUBSCRIBE ：普通订阅

+ PSUBSCRIBE ：模式订阅（正则表达式）

  > subscribe channelA

###### 发布

+ PUBLISH

  > publish channelA message_123

###### 退订

+ UNSUBSCRIBE ：普通退订
+ PUNSUBSCRIBE ：模式退订

###### pub/sub 模式

+ 实现**1 : N 消息队列**

  多个消费者(client) 订阅频道A，某个生产者(client) 在频道A 发布消息，则订阅了 频道A 的client端 都能收到消息！

  如图：client A、B、C 都订阅了 news.it 频道：*SUBSCRIBE "news.it"*

  ![](image\发布订阅.png)

###### 缺点

+ **不会持久化** ：不会保存 已发布的消息，当 client 断开连接 并 重连后，将接收不到 断开期间的消息！



#### Redis 事务

###### 概述

+ Redis 通过 **MULTI、EXEC、WATCH、DISCARD** 命令实现事务（transaction）功能

+ Redis 事务是一个将多个命令请求打包，然后一次性、按顺序的执行多个命令的机制！事务以 MULTI 命令开始，输入多个命令，最后由 EXEC 命令将事务提交（commit）给服务器执行！

+ **缺点：无回滚功能**

  事务中若有一个命令执行失败，则整个事务不会回滚，已执行的命令不会受影响，未执行的命令依旧继续执行！

###### 事务开启

+ *MULTI 命令开启一个事务* ！

###### 事务提交

+ *EXEC 命令提交一个事务* ，redis 会执行事务中包含的所有命令！

  必须有事务开启（MULTI）时才能执行 EXEC！

+ **redis 中事务不会会滚！**

###### 事务取消

+ *DISCARD 命令取消一个事务* ！

  当一个事务开启（MULTI）后，可以在执行 EXEC 命令之前，执行 DISCARD 命令，表示取消这个事务，事务取消后，再执行 EXEC 将报错！

######  事务乐观锁

+ *WATCH 命令监视数据库中的键* ！

+ WATCH 命令是一个*乐观锁*（optimistic locking），它可以*在 事务开启之前 监视任意数量的数据库键，并在事务提交时，检查被监视的键是否至少有一个被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回 nil*（空值：代表事务执行失败）

+ WATCH 监视命令 必须在 事务开启前执行，开启（MULTI）事务之后 执行 WATCH 不合法！

+ **监视机制**

  1. 事务开启前，执行 WATCH 监视任意的 数据库键！

  2. 当开始监视某个键后，直到执行 EXEC 命令之前，如果有其他客户端修改数据库状态*（例如：SET、LPUSH、SADD、ZREM、HSET、DEL、FLUSHDB等）*，本客户端便会检查自己监视的键是否被修改，如果被修改，则将本客户端的事务状态标识为 **REDIS_DIRTY_CAS** ，表示**事务安全被破坏**！

  3. 当收到 EXEC 命令时，客户端会根据事务状态标识决定是否执行事务：

     + 如果*状态为 REDIS_DIRTY_CAS* 则表明，客户端监视的键当中，至少有一个键被修改了，此时提交事务将不安全，所以*拒绝提交事务*，并返回 *nil* （事务中的命令不会被执行！）
     + 如果状态不是 REDIS_DIRTY_CAS，则客户端监视的键没有被修改，或者该客户端没有监视任何键，所以事务是安全的，事务将被提交！

     ![](image\事务.png)

+ 注意：

  由于只要有其他客户端修改了本客户端监视的键，则本客户端的事务状态就会被标识为 REDIS_DIRTY_CAS，执行 EXEC 命令时将拒绝提交事务！

  所以：事务是否能提交成功，与 事务中包含的命令无关，即使被修改的键在事务包含的命令中没有被访问到，依旧是无法提交事务的！

###### 事务 的 ACID

+ 事务的四大特性

  传统关系型数据库中，使用 ACID 性质检验事务的可靠性和安全性！

  > **A （atomic）原子性 **
  >
  > +  *事务的原子性是指：数据库会将事务中的多个操作当成一个不可分割的整体执行，执行过程中不可被中断！要么就都不执行！*
  >
  > **C （consistency）一致性**
  >
  > + *事务的原子性是指：如果数据库在执行事务之前是一致的，那么在执行事务之后，无论事务是否执行成功，数据库也应该是一致性的！*
  >
  > **I （isolation）隔离性 **
  >
  > + *事务的隔离性是指：事务之间相互独立，互不影响，即使有多个事务并发地执行，并发执行的结果与串行执行的结果是完全相同的！*
  >
  > **D （durability）持久性 **
  >
  > + *事务的持久性是指：当事务执行完毕时，事务执行的结果将永久性保存到存储介质中，即使之后数据库宕机，数据也不会丢失！*

+ Redis 的 ACID

  在 redis 中事务总是具有 原子性、一致性、隔离性，并且当 redis 在某种特定的持久化模式下，事务也具有 持久性！

+ *原子性*

  redis 的事务要么都执行，要么都不执行！

  如上述的 监视功能，如果被修改，则事务拒绝执行，事务中的命令都不会被执行！一旦事务执行，则所有命令都会被执行，尽管中间有命令执行出错，也不会影响到其他命令的执行！

  **redis 中的事务，不会回滚！**

+ *一致性*

  **一致：指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据！**

  redis 能在事务执行前后保证事务的一致性！

  + 执行出错时，出错的指令不会影响其他指令的执行！

  + 宕机时，服务器重启后，会根据其持久化机制，将数据会恢复到宕机前的一致性状态，如果没有开启持久化，则重启后数据库将是空白的，这与宕机前的一致，因此也是一致的！

+ *隔离性*

  redis 使用 单线程执行事务，并且服务器能保证，在执行事务期间不会产生中断，因此 redis 总时以串行的方式执行，事务总是具有隔离性！

+ *持久性*

  redis 的事务只是简单的用队列将 redis 命令包裹起来，并没有为事务提供额外的持久化功能！所以 redis 事务的持久性，取决于 redis 所使用的持久化模式！

#### Redis 慢查询日志

+ Redis 的慢查询日志功能 用于 记录执行时间 超过给定时长 的命令请求，用户可以通过这个功能产生的日志，监视和优化查询速度！

###### 相关配置

```shell
slowlog-log-slower-than time # 执行时间超过 time微秒 的命令请求，会被记录到日志上（1s = 10^6 us ）
slowlog-max-len length # 配置服务器最多能保存多少条慢查询日志
```

```shell
# 上述配置，除了在配置文件中配置，还能在 client 中通过 CONFIG SET 命令配置
> CONFIG SET slowlog-log-slower-than 0	# 配置：所有命令都会被记录！
> CONFIG SET slowlog-max-len 5	# 配置：只保存最近 5 条慢查询日志！
```

###### 相关命令

![](image\slowlog 相关命令.png)

+ **slowlog get count** ：查看 count条 日志信息（默认返回 10 条）

  ```c
  /*
   · 查看服务器中保存的慢查询日志！
   	每一条记录返回：
   		1、每条日志的唯一标识符
   		2、命令执行时的 UNIX 时间戳
   		3、命令执行的时长 （微妙）
   		4、命令 及 命令参数
  */
  ```

+ **slowlog len** ：查看日志的数量

+ **slowlog reset** ：清空慢查询日志（reset 本身这条命令会被记录下来）

#### Redis 持久化

+ Redis 是基于内存的 key-value 数据库，它将自己的数据库状态存储在内存中，如果不做持久化，那么服务器下线重启后，内存中的数据将会全部丢失！
+ Redis 提供了两种持久化实现方式：RDB快照持久化、AOF持久化！ 

##### RDB 持久化

###### 概述

+ **RDB 文件是一个被压缩过的二进制文件，保存在磁盘中，它是某个时间点上数据库状态的快照。也就是说，RDB文件直接保存的是 数据库的键值对！通过 RDB 文件，能还原数据库的状态，避免数据意外丢失**！

+ 创建 RDB 文件：

  可以通过 *SAVE、BGSAVE* 命令手动持久化生成 RDB 文件，也可以根据*服务器配置项：save属性*，定期自动做 RDB持久化！

+ 载入 RDB 文件：

  RDB 文件的载入，是服务器*启动时自动执行* 的！服务器启动时，若关闭了 AOF 持久化功能，则会检测是否存在 RDB 文件，如果存在，就会自动载入。*载入 RDB 文件期间，服务器会处于阻塞状态* ，直到载入工作完成为止！

###### SAVE vs BGSAVE

+ [Redis RDB持久化详解](https://www.jianshu.com/p/0d0ab927e11b)

+ *SAVE*

  执行一个同步操作，将当前 Redis 实例的所有数据快照（snapshot）以 RDB 文件的形式保存到硬盘，会阻塞主进程，所有 client socket 无法连接，SAVE 完成后，主进程开始工作，客户端可以连接！


+ *BGSAVE*

  与 save 命令不同，**bgsave 执行时，会 fork 一个子进程，将持久化任务交由子进程完成**，而主进程则继续处理客户端请求！**fork 子进程时，redis 采用了 copy-on-write 的策略，只有当主进程有写命令时，子进程才会拷贝数据副本！**

  ```c
  /*
   · 在执行 BGSAVE 期间：服务器对待 SAVE、BGSAVE、BGREWRITEAOF 等命令的态度会有所不同！
   
   	1、在执行 bgsave 期间，服务器将拒绝客户端的 save、bgsave 命令请求！
   	  因为，不论是 save、bgsave 命令，创建rdb文件的工作都是通过调用 rdbSave 函数完成的，如果同时存在多个进程执行 rdbSave,可能产生竞争条件！
   	 
   	2、bgsave 命令与 bgrewriteaof 命令不能同时执行！
  	  1）如果 bgsave 命令正在执行，那么 客户端 发送的 bgrewriteaof 命令将被延迟，直到 bgsave 执行完毕！
  	  2）如果 bgrewrieteaof 命令正在执行，那么 客户端 发送的 bgsave 命令将被拒绝！
  	
  	因为：bgsave、bgreweriteaof 命令都是由 子进程 执行，虽然两者之间没有冲突，但是，为了性能考虑，两者不能同时执行！如果并发两个子进程都同时执行大量的 磁盘 写入，redis 服务器的性能会受到影响！
  */
  ```

###### 配置自动持久化

+ 可以在 服务器中配置 自动并定期做 RDB持久化！

+ 用于可**通过 save 选项设置多个 持久化条件**，只要其中任意一个条件满足，则服务器会**自动执行 BGSAVE 命令**！

  ```c
  /*
   · save 默认配置如下：
   	
   	save 900 1		：服务器在 900s 内，至少修改了 1次 数据库时
   	save 300 10		：服务器在 300s 内，至少修改了 10次 数据库时
   	save 60 10000	：服务器在 60s 内，至少修改了 10000次 数据库时
   	
   	在上述时限内，修改次数满足条件时，服务器将自动执行 bgsave 命令！
  */
  ```

+ redis 为该功能维护了两个属性：*dirty计数器、lastsave属性*

  dirty计数器：记录距离上一次成功执行 bgsave 之后，数据库被修改的次数！

  lastsave属性：是一个 UNIX 时间戳，记录上一次成功执行 bgsave 的时间！

+ redis 通过*时间事件 serverCrom*，（100ms 一次）*周期性地检查是否满足 save 属性配置条件* ，如果满足则执行 bgsave 命令！

##### AOF 持久化

###### 概述

+ 配置 **appendonly yes ：开启 AOF 持久化模式**

+ AOF（Append Only File）持久化功能，与 RDB持久化 直接保存数据库键值对的方式不同，它是以 追加 Redis 写命令到文件的方式，达到数据持久化的目的！

  ![](image\aof持久化.png)

+ 被写入 AOF文件的所有命令都是以 Redis的命令请求协议 的格式保存的！

###### AOF 持久化实现

+ AOF 持久化可以分为**命令追加（append）、文件写入与同步（fsync）**！

+ *命令追加*

  redis 服务器为 AOF持久化功能，维护了一个 *aof_buf 缓冲区* ！

  当服务器执行完一个写命令之后，会以协议的格式将该命令追加到 aof_buf 缓冲区的末尾！

+ *AOF文件写入 与 同步*

  redis 会通过 **appendfsync 配置项**，*决定何时将 aof_buf 缓冲区中的内容写入 AOF 文件* ！

  appendfsync 的三个可选参数：

  1. **always**：*每次执行完写命令，都将缓冲区中的内容写入 AOF 文件中* ！

     ```c
     /*
      · appendfsync always
     
      · 每次写命令都会立即同步到 AOF 文件中，也就是说，每次都会涉及到磁盘IO，降低 redis 性能！
      	但是，这是最安全的，即使，突发宕机，最多也只会丢失一条写命令产生的数据！
     */
     ```

  2. **everysec**：**（默认策略）** *以每秒1次的频率，将 aof 缓冲区写入 AOF文件中* ！

     ``` c
     /*
      · appendfsync everysec
     
      · 每个一秒 创建一个子线程，并将缓冲区写入 AOF 文件。
      	相较于 always 策略，everysec 策略的性能较高，并且，最多会丢失 1s 的命令数据！
     */
     ```

  3. **no**：*何时写入 AOF文件，取决于操作系统* ！

     ```c
     /*
      · appendfsync no
     
      · 由操作系统控制何时写入 AOF 文件，不会频繁的发生 磁盘IO，所以这是三种策略中性能最高的！
      	但是，由于这种模式下，写命令缓冲堆积较多，所以，该模式单次同步的时长是最长的，同时，当服务器宕机后，会丢失自上次写入 AOF文件之后所有的写数据！所以安全性也是最差的！
     */
     ```

###### fsync / fdatasync

+ *fsync 与 fdatasync 是同步函数*

+ 现代操作系统为了提高文件写入的效率，当执行 write 文件写入时，会将数据首先存放到内存缓冲区中，等待缓冲区被填满 或者 超过指定时限之后，才会真正将数据写入文件（磁盘）！

  这种做法，虽然提高了效率，但是带来了数据安全问题，一旦服务器宕机，缓冲区中的数据将全部丢失，为了写入数据的安全性，系统提供了 fsync 与 fdatasync 两个同步函数！

+ *fsync 与 fdatasync 同步函数能够强制操作系统立即将缓冲区中的数据写入磁盘中，从而确保数据写入的安全性* ！

###### AOF 文件重写

+ *BGREWRITEAOF*

  **bgrewriteaof**命令用于 异步执行一个 AOF 文件重写操作，避免 随着 写操作的增加导致 AOF 文件体积增大，重写会创建一个**当前 AOF 的体积优化版本**！

+ *AOF 体积膨胀的影响*
  + 增加计算机储存压力
  + AOF 还原数据库状态的时间会增加

+ *体积优化*

  直接从数据库中读取 现有的 key-value，这就是数据库当前的状态，代替了之前记录该键值对的多个命令！这就使得重写的 AOF 文件不会包含任何浪费空间的冗余命令，使得文件体积比原有的 AOF 文件小很多！

+ *重写过程*

  + 由于重写过程中，主进程依旧对外提供服务，可能造成主进程与子进程之间数据的不一致！所以，redis 是维护了一个**AOF重写缓冲**！从 fork 一个子进程开始，就创建一个 AOF 重写缓存，主进程任何的写操作都会追加缓冲区中！

  + 当子进程重写完毕后，给主进程发送一个信号，主进程收到信号后，阻塞所有客户端请求，将重写缓冲的内容，写入新的AOF文件中，并将新文件该命覆盖旧文件，完成以后重写完毕，主进程继续处理命令请求！

  *注意：*如果 BGREWRITEAOF 执行失败，不会对原有数据造成影响，重写操作只会在 没有其他持久化操作时触发，从 Redis2.4 开始，AOF 重写由 Redis 自行触发，BGREWRITEAOF 指令仅仅用于手动触发重写

  [详见：Redis 持久化AOF重写 原理解析！](https://www.cnblogs.com/fanBlog/p/9707422.html) |  [BGREWEITEAOF 指令](http://doc.redisfans.com/server/bgrewriteaof.html)

###### AOF 文件载入

+ 在 AOF持久化模式下，系统启动该时，会自动检测是否存在 AOF 文件，如果存在，则会遍历 AOF 文件读取保存的命令，以及来还原数据库状态！

+ 恢复数据库流程：

  1. 创建一个不带网络连接的伪客户端。

     因为 redis 命令只能在 客户端中执行，而所要执行的命令来自于 AOF文件，并非网络连接，所以需要不带网络的伪客户端！

  2. 从 AOF 文件中分析并读取一条写命令。

  3. 使用伪客户端执行读出的写命令。

  4. 循环执行步骤2、3，直到AOF文件中所有写命令读取完毕！

     ![](image\aof恢复数据库.png)

##### RDB vs AOF

###### Redis 如何选择

+ AOF 的更新频率通常比 RDB文件的更新频率高，所以：

  1. 如果服务器开启了 AOF持久化功能，那么服务器会优先使用 AOF 文件还原数据库状态！
  2. 只有在 AOF 持久化功能关闭时，服务器才会使用 RDB 文件来还原数据库状态！

  ![](image\持久化文件载入.png)

###### 我们 如何选择

+ *AOF 与 RDB 数据丢失情况*：

  RDB 保存的是一个时间点的快照，如果 Redis 出现故障，就会丢失最后一次RDB持久化之后的所有数据！如果最后一次 RDB持久化之后，QPS 很高，那将会丢失很多数据！

  AOF 持久化最理想的情况下，最多丢失一条命令，数据能达到高度的完整性，如果 appendfsync 配置项参数是 everysec 则，最多丢失 1s 内的数据，相较于 RDB持久化，这无疑也数据完整性也是较高的！但是，这会发生频繁的磁盘 IO，服务器性能相较于 RDB 的方式，会有所下降！

+ *AOF 与 RDB 文件加载的过程*：

  RDB 只需要把相应的数据加载到内存中生成相应的数据结构即可；

  AOF 文件的加载，会首先创建一个伪客户端，然后把命令发送给 伪客户端，客户端再执行命令生成数据！相对来说，RDB 的加载方式，比AOF文件的加载方式要快的多！

+ *AOF 与 RDB 各有优缺点*：

  如果使用 RDB持久化，那么，文件的加载速度很快，但是可能会丢失大量的数据！

  如果使用 AOF持久化，那么，要想将数据丢失降到最低，服务器配置项 appendfsync 就必须是 always 、everysec，这需要频繁地 发生磁盘IO，服务器的性能相较于 RDB的方式会有所下降！并且文件的加载速度，也比 RDB文件慢！

+ 实际应用中，应该*综合两者的优缺点*，**混合持久化 ** *Redis 4.0 新增* ：

  混合持久化是指，**进行AOF重写时**，*子进程将当前时间点的数据快照保存为 RDB 文件格式*，而*父进程累计命令保存为 AOF 文件格式* ！

  加载时，首先会判断文件是否 RDB文件，如果是则以 RDB格式加载数据，加载完RDB后，再按照 AOF格式加载剩余部分！

  > aof-use-rdb-preamble **yes** **开启混合持久化**

+ **混合持久化的优势**：

  依旧是以 AOF 持久化为主要形式，能在保证性能的同时，将数据丢失尽可能的减少！

  当 AOF 文件体积膨胀后，AOF文件重写时，以 RDB为主，保存当前时间点的数据快照，而以 AOF文件接收后续命令作为补充！这能使得，在文件加载时，能够迅速恢复数据库！

###### 为什么不直接使用主进程进行 RDB持久化、AOF 重写？

因为会阻塞客户端的连接！而启动子进程时，主进程依旧可以向客户端提供服务！

###### 为什么是 子进程？而不是 多线程？

这是因为 Redis 是`单进程单线程`的工作模型，如果同一个进程内启动多线程，就会造成对共享数据的竞争，就需要使用到锁！

Redis 选择启用子进程，使其`独立拥有一份内存拷贝`，这就不需要锁来保证共享资源的安全性，因为两个进程之间是相互独立的！这就避免了使用锁减低性能！

*【注意 1】*fork 使用 linux 的` copy-on-write `思想，开始时父子进程共用一个内存地址，但是当其中任意一个进程有写操作时，就阻塞另一个进程，并建立数据副本！所以，有写操作时，fork 会阻塞主进程，子进程复制数据副本！如果库中占用内存大，则 fork 将会消耗较长的时间，这段时间内，主进程无法响应客户端！

*【注意 2】*fork 会导致暂时性的 空间翻倍！

#### Redis 内存淘汰策略

> maxmemory < bytes >	*配置内存大小*
>
> maxmemory-policy < policy >	*配置过期策略：默认为 noeviction 策略*

###### 8 中淘汰策略

1. **noeviction**

   当占用内存达到限制之后，redis 将拒绝执行写命令，并且返回错误！

2. **volatile-ttl**

   淘汰（近似）剩余过期时间最少的键！

3. **allkeys-lru**

   对于所有键，使用近似的 LRU 算法，淘汰最久未使用的键！

4. **volatile-lru**

   对于设置了过期时间的键，使用近似的 LRU 算法，淘汰最久未使用键！

5. **allkeys-lfu**

   对于所有键，使用近似的 LFU 算法，淘汰 最少使用的键！

6. **volatile-lfu**

   对于设置了过期时间的键，使用近似的 LFU 算法，淘汰 最少使用的键！

7. **allkeys-random**

   对于所有键，随机淘汰一个键！

8. **volatile-random**

   对于设置了过期时间的键，随机淘汰一个键！

###### 近似淘汰

+ 为了节约内存，对于 lru、lfu、ttl 等淘汰策略来说，都不是精确的淘汰，而是近似精确的淘汰结果！

###### Redis LRU 

+ redis 默认会维护 5 个样品数据，当达到内存限制之后，从 5 个中挑选最合适的键进行淘汰！随后，随机从数据库中获取一个键添加到 样品中！

+ 可以通过 **maxmemory-samples** 配置项，配置样品的个数！

  > maxmemory-samples 5 *redis 默认使用 5 个样品键*
  >
  > + *redis 官方提到，默认的 5 个样品数量已经能得到较理想的结果。*
  >
  > + *当设置为 10 个时，结果便会非常接近全局的 LRU ，但是 这会耗费 CPU！*
  >
  > + *当设置为 3 个时，淘汰速度会非常快，但是 不精确！*

+ 这是一种局部 LRU 的策略！最开始时，表现的较差，而后，随着淘汰次数的增加，样品中的键将是全局最适合被删除的键！

+ [LRU 算法详解](https://mp.weixin.qq.com/s/KgXE195lmX0fUrqLBMWbqA)

+ *【补充 —— 手写 lru】*

  ```java
  // LinkedHashMap 已经实现了 LRU  
  
  /*
   · 实现1
   	当容量超过 100 时，开始执行 LRU：将最少未使用的 TimeoutInfoHolder 对象 evict 掉
  */
  final Map<Long,TimeoutInfoHolder> timoutInfoHandlers = 
      Collections.synchronizedMap(new LinkedHashMap<Long,TimeoutInfoHolder>(100,.75f,true)){
      @Override
      protected boolean removeEldestEntry(Map.Entry eldest){
          return size()>100;
      }
  }
  
  /*
   · 实现2
  */
  
  class LRUHandler<K,V> extends LinkedHashMap<K,V>{
      private int cacheSize;
      /**
       * 设置最大缓存
       */
      public LRUHandler(int cacheSize){
          // true 表示让 LinkedHashMap 按照访问顺序进行排序，最近访问的放在头部，最老访问的放在尾部 
          super((int)Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
          this.cacheSize=cacheSize;
      }
      @Override
      protected boolean removeEldestEntry(Map.Entry<K,V> eldest){
          // 当 map 中的数据量大于 指定的缓存个数的时候就自动删除最老的数据！ 
          return size()>cacheSize;
      }
  }
  ```

#### Redis 服务进程

redis 的服务进程就是一个事件循环，这个循环中的*文件事件* 负责接收客户端的命令请求，将命令执行结果回复给客户端；而 循环中的*时间事件* 则负责 执行像 serverCron函数这样 需要定时运行的函数！