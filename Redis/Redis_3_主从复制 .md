#### 【Redis_主从复制】

##### 介绍

+ 在 redis-cli 中通过 **slaveof / SLAVEOF** 命令构建`主从复制关系`

  slaveof 表示 让当前服务器 复制（replicate） 另一个服务器，则 被复制的服务器为*主服务器（master）*，而 当前服务器称为 *从服务器（slave）* 。

+ 为什么做主从复制？

  1. 数据容灾（*哨兵的机制下，解决单点故障，实现数据容灾* ）

     Redis 单点容易出现单点故障问题，通过主从复制，保证主从节点数据的一致性，能提升 Redis 服务的可靠性！然后使用**哨兵**监听主节点的存活状态，一旦主服务器宕机，可以立即从服务器升级为主服务器，从而避免 Redis 服务中断！

  2. 数据冗余：实现数据热备份？

  3. 读写分离

     单台服务器能支撑的 QPS 是有上限的，通过部署 主从复制，主服务器处理写请求，从服务器只处理读请求，能有效提升 Redis 的服务性能！

+ **INFO inplication** 命令能查看 主从服务器信息！

##### 主从复制流程

+ 从服务器 接收到 slaveof 命令后，会主动连接主服务器 请求同步数据。但不是一蹴而就的，主要流程有：

  1、记录主服务器地址  和 端口

  2、建立 socket 连接

  3、发送 PING 命令：确认连接是否正确

  4、发送 AUTH 命令：密码认证

  5、发送 REPLCONF 命令：同步从节点端口信息

  6、发送 PSYNC 命令：同步数据

  7、命令传播

###### 记录主服务器的地址 和 端口

+ 当 client 端向从服务器发送 slaveof 请求后，从服务器会将 主服务器的 ip 和 port 记录在自己的 *masterhost* 和 *masterport* 属性中！

  ```c
  struct redisServer{
      // ...
      // 主服务器 ip
      char * masterhost;
      // 主服务器 port
      int masterport;
      // ...
  } redisServer;
  ```

+ `slaveof 是一个 异步命令`，当从服务器记录完 主服务器的 ip+port 后，便向  client 端返回 OK，表示复制指令已经被接收，而实际的 复制工作 在返回 OK 之后才真正的开始执行！

  ```shell
  # 在 从服务器 12345 上请求建立主从复制关系：主节点ip + 主节点 port
  127.0.0.1:12345> slaveof 127.0.0.1 6379
  OK
  ```

###### 建立 socket 连接

+ slaveof 命令执行完成之后，从服务器 将根据 命令所设置的 ip+port ，创建 socket 连接主服务器！

+ 如果 socket 成功连接，则 从服务器将为这个套接字关联 一个 专门用于处理复制工作的 文件事件处理器！处理器负责处理后续的复制工作，例如：接收 RDB 文件、接受 主服务器传播的 写命令等！`（主从节点都需要各自关联 文件处理器中的 复制处理器，专门处理 主从复制 事件！）`

+ 建立连接之后，从服务器 将被视为 主服务器的 客户端！（因为，后续步骤都是 以 从服务器向主服务器 发送命令请求 进行的）

  ![](image\主从服务器的关系.png)

###### 发送 PING 命令

+ 建立完 socket 连接之后，从服务器 向 主服务器发送 PING 命令！

+ 作用：

  1. *检查套接字的读写状态是否正常* ：因为 连接完 socket ，双方还未使用 socket 进行通信！
  2. *检查主服务器能否正常处理命令请求* ：因为后续步骤都必须保证 主服务器能正常处理 命令请求！

+ 主服务器响应：

  1. 返回一个命令回复，但 从服务器不能在规定的时限（timeout）内读取出命令的回复内容，表示网络连接状态不佳 —— `复制工作中断，需重新创建套接字连接`！
  2. 主服务器 向 从服务器返回一个错误，表示 主服务器 暂时无法 处理 从服务器 的命令请求 —— `复制工作中断，需重新创建套接字连接`！
  3. 从服务器读取到 **”PONG“ **回复，表示主从服务器之间*网络连接状态正常*，并且*主服务器可以正常处理从服务器发送的命令请求* ！

  ![](image\主从 PING.png)

###### 发送 AUTH 命令

+ 从服务器收到 主服务器的 ”PONG“ 回复后，下一步决定，是否进行身份验证！

  1. 如果从服务器 设置了 *masterauth* 选项，则进行身份（密码）验证。
  2. 如果没有设置，则不进行身份验证！

+ 从服务器 向 主服务器 发送**AUHT 命令** 验证，参数为配置文件中 masterauth 设定的值！

  ![](image\主服务器密码验证.png)

+ 验证结果

  1. 主服务器没有设定 *requirepass* ，并且 从服务器 也没有设定 masterauth ，则复制工作继续执行！
  2. 从服务器发送的 AUTH 验证密码，与 主服务器中 requirepass 设定的密码相同，则复制工作继续执行！
  3. 其他情况，主服务器将返回错误提示 —— `复制工作中止，需重新创建套接字连接，直到验证通过，或者从服务器放弃为止`！

  ![](image\密码验证过程.png)

###### 发送 REPLCONF 命令

+ 身份验证之后，从服务器执行 **REPLCONF** 命令，向主服务器发送 从服务器监听的端口！

  ```shell
  >>> REPLCONF listening-port <port-number> 
  # 例如
  >>> REPLCONF listening-port 12345
  ```

+ 主服务器接收到 命令后，会将端口号 记录在 从服务器对应的 客户端状态的 *slave_listening_port* 属性中！

  ```c
  typedef struct redisClient{
      // ...
      // 从服务器的监听端口
      int slave_listening_port;
      // ...
  } redisClient;
  ```

###### 发送 PSYNC 命令

+ 从服务器 向 主服务器 发送 **PSYNC** 命令，执行*数据同步*  操作：*将自己的数据库状态 更新为 主服务器当前数据库的状态* ！
+ 这之后，主从服务器 互为对方的客户端！

###### 命令传播

+ 完成 主从数据同步之后，主从复制的关系正式搭建完毕，此时主从服务器两者的数据库达到一致状态！

+ **问题：**

  但是，这种一致状态并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致！

+ 为保证主从数据的一致性，主服务器需要对从服务器执行**命令传播**操作：主服务器上执行的任何**写命令**，也就是造成数据不一致的命令，都需要同步到 从服务器上，当从服务器接收命令并执行之后，主从服务器的状态恢复一致！

##### 主从同步 SYNC / PSYNC

###### Redis 之 复制功能

+ redis 的复制功能分为 *数据同步*  和 *命令传播*  两个操作：

  数据同步 ：用于将 从服务器的数据库状态更新至 主服务器当前的数据库状态！

  命令传播 ：用于 在主服务器的数据库状态被修改，导致主从服务器状态不一致时，让从服务器的数据库状态重新回到一致状态！

###### Redis 之 数据同步

+ 从服务器对主服务器的 复制（数据同步）分为以下两种情况：
  1. 初次复制：从服务器 `没有复制过 任何主服务器` 或者 `所要复制的主服务器 与上一次 复制的主服务器不同`！
  2. 断线后重复制：处于命令传播阶段的主从服务器，因为网络原因而中断了复制，但是从服务器通过自动重连接重连接上了主服务器，并继续复制主服务器！

###### SYNC

+ **SYNC（full resynchronization） ：完整重同步**命令

+ SYNC 是 Redis2.8 之前，主从数据同步的命令，执行步骤如下：

  1. 从服务器 向 主服务器 发送 SYNC 命令

  2. 主服务器收到 SYNC 命令后，创建子进程，*异步执行 BGSAVE 命令*，在*后台生成一个 RBD文件* `(当前数据库的快照文件：完整重同步)`；在子进程执行 BGSAVE 命令的同时，主进程创建*缓冲区，记录 从现在开始执行的所写命令* ！

  3. 当主服务器的 BGSAVE 命令执行完毕，主服务器会将 生成的 RDB 文件发送给从服务器，**从结点 接收并将 RDB 文件载入数据库**，将自己的数据库状态更新成主服务器 执行 BGSAVE 时的数据库状态！

  4. **主服务器 将缓冲区中的 写命令 发送给从服务器，从服务器接收并执行这些写命令**，将自己的数据库状态更新成主服务器数据库当前的状态！

     数据同步完成！

     ![](image\主从服务器 SYNC 通信过程.png)

###### 数据同步中 SYNC 的弊端

+ *SYNC 是一个耗费资源的命令*，每次执行 SYNC 命令，主从服务器会执行以下操作：

  ```c
  /*
   1、主服务器需要执行 BGSAVE命令 生成 RDB，虽然是 fork 一个子进程异步执行，但是，fork 子进程意味着需要进行 空间拷贝，与 主进程抢占 CPU ，并会在 一段时间内，内存占用翻倍。
   所以，这个操作会耗费主服务器大量的 CPU、内存、磁盘I/O 资源！
  
  2、主服务器需要将自己生成 RDB 文件发送给从服务器，若 RDB 文件较大，则这个发送操作会耗费主从服务器大量的网络资源（流量和带宽），并对主服务器响应命令请求的时间产生影响！
  
   3、接收到 RDB 文件的从服务器需要载入 主服务器发送的 RDB 文件，并在载入期间，从服务器会因为阻塞而无法处理命令请求！
  */
  ```

+ 对于 *初次复制* 同步数据，*需要 SYNC命令 完整重同步* ！

+ 对于 *主从断线重连* 后，redis 2.8 之前使用 *SYNC 命令进行数据 重同步，效率低下* ！

  由于 断线之后重连，导致主从数据库不一致的命令，都是从断线时开始执行的，因此，对于从数据库而言，大多数数据是有效的，*没有必要重新载入 主数据库的快照，因为这是个及其耗费资源*，效率低下 的过程！（如下图）

  ![](image\SYNC 低效率示例.png)

  > 从服务器 只需要 同步 断线开始后 主服务器中的所有写命令 —— 因此 redis2.8 引入 部分重同步 PSYNC ！

###### PSYNC

+ **PSYNC ：部分重同步 + 完整重同步**命令

  `完整重同步：确认是否为 完整重同步过程 与 SYNC 不同，但 数据同步过程与 SYNC 一致`

+ PSYNC 是 Redis2.8 之后，主从数据同步的命令，执行步骤如下：

  `PSYNC 有两种调用方式`

  1. 如果从服务器 *初次复制 该主服务器*，或者之前执行过 *slaveof on one* 命令，则 从服务器 向 主服务器 发送 **PSYNC ? -1** 命令 ：主动请求**完整重同步** ！

     > PSYNC ? -1

  2. 如果从服务器已经复制过主服务器，则 从服务器 向 主服务器发送 **PSYNC < runid > < offset >** 命令：请求**部分重同步**！

     > PSYNC < runid > < offset >
     >
     > *runid ：上一次复制的 主服务器的运行 ID* 
     >
     > *offset ：从服务器当前的 复制偏移量*

     > 接收到 PSYNC < runid > < offset > 命令的 主服务器 会通过 runid 、offset 参数判断应该对从服务器执行哪种同步操作！

  `接收到 PSYNC 命令的 主服务器，根据情况，会有以下三种回复`

  1. 如果主服务器回复 **+ FULLRESYNC < runid > < offset >** ：表示主服务器将与从服务器 进行**完整重同步**操作！

     > *runid ：主服务器的运行 ID，从服务器会将这个 ID 保存起来，在下一次发送 PSYNC 命令时使用*
     >
     > *offset ：主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量*

  2. 如果主服务器回复 **+ CONTINUE** ：表示主服务器 与 从服务器 进行**部分重同步**，从服务器只需要等待主服务器发送 自己缺少的那部分数据！

  3. 如果主服务器回复 **- ERR** ：表示 主服务器版本低于 2.8 ，识别不了 PSYNC命令，**从服务器将向主服务器发送 SYNC 命令，进行 完整重同步**！

  ![](image\PSYNC执行流程.png)

###### 数据同步中 PSYNC 的优势

+ 对比 SYNC 命令与 PSYNC 命令，两者都能在断线时，使得主从数据库重新回到一致状态！但是 **部分重同步 消耗的资源却少很多！**

  执行 SYNC 命令需要生成、传送、载入 整个RDB文件，而部分重同步，主服务器只需要**向从服务器 返送缺少的命令**，从服务器接收并执行即可！

+ PSYNC 部分重同步 通信过程

  ![](image\PSYNC 部分重同步通信过程.png)

+ PSYNC 断线重连示例

  ![](image\PSYNC 部分重同步示例.png)

###### PSYNC 部分重同步实现

+ PSYNC 部分重同步 功能由三个部分组成：

  > 1. 服务器的运行 ID（run ID）
  > 2. 主服务器的复制偏移量 和 从服务器的复制偏移量（replication offset）
  > 3. 主服务器的复制积压缓冲区（replication backlog）

+ **服务器运行 ID** ：判断 执行完整重同步 还是 尝试执行部分重同步！

  + 服务器运行 id

    每个 Redis 服务器 都会有自己的 运行ID，这个 ID 在服务器自动时自动生成，由 40个 随机的 十六进制字符组成！

  + 主从初次复制时，主服务器会将自己的 运行ID 传送给 从服务器，从服务器保存 运行ID，在断线重连时使用！

  + 主从断线重连时，主服务器会检查 从服务器发送的 运行ID，并判断：

    1. 如果从服务器发送的 运行ID，与 主服务器**运行ID 一致**，则说明是断线重连，主服务器**尝试执行 部分重同步**！
    2. 如果从服务器发送的 运行ID，与 主服务器**运行ID 不一致**，则说明 从服务器上一次复制的并非当前主服务器，于是 主服务器**执行完整重同步**！

+ **复制偏移量** ：判断状态是否一致！

  主从服务器都需要维护自己的 复制偏移量：

  + *主服务器* 每次向 从服务器*传播 N 个字节的数据* 时，就将*自己的复制偏移量 + N*
  + *从服务器* 每次从主服务器那里 *接收 N 个字节的数据* 时，就将*自己的复制偏移量 + N* 

  通过对比主从服务器的复制偏移量，就能直到主从是否一致：

  > + 如果主从处于一致状态，则主从的复制偏移量总是相同的！
  > + 如果主从复制偏移量不相同，则 主从不一致！

+ **复制积压缓冲区** ：（状态不一致）判断 执行哪种重同步！

  + 复制积压缓冲区是一个 固定长度的先进先出（FIFO）队列，用于存放传播的命令，并为队列中的每个字节维护一个偏移量。

    ![](image\复制积压缓冲区.png)

  + *固定长度的先进先出（FIFO）队列*

    *当 入队元素数量 > 队列的长度时，最先入队的元素会被弹出，而新元素会被放入队列中！*

  + `工作过程：`
    + 当主服务器进行**命令传播**时，不仅会向从服务器发送命令，**还会将命令存入复制积压缓冲区中**，并为缓冲区中的每个字节记录相应的偏移量。
    + 当从服务器重连，会通过 PSYNC 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个偏移量决定执行哪种 数据同步（部分重同步？完整重同步？）
      1. 如果，offset 偏移量之后的数据（也就是 offset+1 开始的指令）仍然存在于复制积压缓冲区中，则主服务器执行 *部分重同步* ！
      2. 如果，offset 偏移量之后的数据（也就是 offset+1 开始的指令）不存在与于 复制积压缓冲区中，则主服务器执行 *完整重同步* ！

  + 复制积压缓冲区*大小设置* **repl-backlog-size 属性**

    + redis 为复制积压缓冲区 设置的默认大小为 1MB！如果 *主服务器需要执行大量的写命令* 或者 *主从服务器断线后，重连所需的时间较长* ，则需要根据实际情况设定大小！

      如果 复制积压缓冲区 **大小设置不合理**，则 **PSYNC 命令的复制重同步 将不能正常发挥作用**！

    + 可根据如下公式设定 大小：

      > second * write_size_per_second
      second：从服务器断线后重新连接上主服务器所需的平均时间！

      write_size_per_second：主服务器平均每秒产生的写命令数量（协议格式的写命令的长度总和）

    + 为安全起见大小可设置为 **2 * second * write_size_per_second** ，保证绝大部分的断线情况都能使用重同步处理！

  + 为什么 是 固定长度的队列？

    答：复制积压缓冲区的目的是：缓存 断线后从服务器上缺失的 写命令，很明显，这个写命令是有限的，所以缓存队列的长度也必须是有限的，否则会浪费大量的内存资源！

##### 主从 心跳检测

###### 为什么要心跳检测

+ redis2.8 之前，为了保证主从数据一致性，使用 命令传播 功能向从服务求同步主服务器上的写命令！但是，这些命令在传播过程中，很可能因为网络原因而丢失，这是 主从服务器都不会检测到的！

  若 传播命令丢失，则主从数据将不一致，**为了保证 命令能准确传播，因此 redis2.8 中引入 心跳检测**！

###### 心跳检测机制

+ Redis 2.8增加心跳检测：在命令传播阶段，从服务器**默认**会以 **每秒1次** 的频率，向主服务器发送心跳检测命令 **REPLCONF ACK < replication_offset >**

  > REPLCONF ACK < replication_offset >
  >
  > *replication_offset ：从服务器当前的复制偏移量*

+ REPLCONF ACK 命令的作用

  > 1. 检测主从服务器的网络连接状态
  > 2. 辅助实现 min-slaves 选项
  > 3. 检测命令丢失

###### 作用1：检测网络连接状态

+ 主从服务器通过收发 REPLCONF ACK 命令来检查两者之间的网络连接是否正常！

+ 如果 主服务器**超过 1s 没有收到 从服务器的 REPLCONF ACK 命令**，那主服务器就知道**主从服务器之间连接出现问题**！

+ 在 主服务器的 client端 发送 *INFO replication* 指令，能在 *slave 栏查看 lag 属性*

  lag 属性：主服务器 距离上一次 接收 该从服务器的 REPLCONF ACK 指令 过了多少秒！

  一般情况下，lag 值应该在 0s、1s 之间跳动，如果超过 1s ，那么说明 主从连接出现故障！

###### 作用2：实现 min-slaves 配置

+ Redis 的 **min-slaves-to-write** 、**min-slaves-max-lag** 两个配置选项，**防止 主服务器在不安全状态下执行写命令**！

  > min-slaves-to-write `n`*当从服务器少于 n 个 时，主服务器拒绝执行 写命令；最少设置为 0*
  >
  > min-slaves-max-lag `m`	*当上述 n 个从服务器的延迟值都 >=  m秒 时，主服务器拒绝执行 写命令*

+ 示例：

  ```shell
  # 配置：当 从服务器少于 3 个时，主服务将拒绝执行写命令！
  min-slaves-to-write 3
  # 配置：当 3 个从服务器的延迟值>= 10s 时，主服务器将拒绝执行写命令！
  # 延迟值：lag：就是上述 lag 属性：距离上一次 从服务器 发送的 REPLCONF ACK 指令的时长！
  min-slaves-max-lag 10
  
  # 满足任意条件，则主服务器将不可写，只可读！
  # 写命令会报错：(error) NOREPLCAS Not enough good slaves to write
  ```

###### 作用3：检测命令丢失

+ 如果因为 网络故障，主服务器 给从服务器 传播的命令在半路丢失，则 当从服务器发送 REPLCONF ACK 命令时，主服务器将会发现 *从服务器当前的复制偏移量 < 自己的复制偏移量* ，此时，*主服务器就会 补发缺失的数据* ！

+ 数据补发

  主服务器 根据 从服务器 提交的 复制偏移量（replication_offset） ，从 复制积压缓冲区 中取出从服务器缺失的数据，重新发送给从服务器！

+ 注意：主服务器向从服务器 补发缺失数据的原理 与 部分重同步 相似。

  两者的区别在于：补发缺失数据 是在 主从服务器没有断线的情况下执行的，而部分重同步 是在主从断线重连后执行的！

##### 关闭持久化，复制的安全性！

+ 在使用 Redis 的复制功能的设置中，强烈建议在 master 和 slave 中启用持久化功能，当*不可能启用持久化时*，例如由于非常慢的磁盘性能而导致的延迟问题，应该配置实例来*避免重置后自动重启* ！ 

+ 例如：该案例中，master 和 slave 中的数据将被全部删除！

  1. 设置 节点A 为 master，并关闭它的持久化设置，节点 B 和 C 分别为两个从节点，从 主节点A 中复制数据！

  2. 若 主节点A 崩溃，但是 它有一些自动重启的系统，能够迅速重启 主节点A 的进程！

     这时，由于 主节点A 的持久化被关闭，节点重启后，数据库为空！

  3. 从节点B 和 从节点C 会从主节点A 中复制数据，但是，主节点A 的数据库为空，因此复制的结果就是 两个从节点会销毁自身之前的数据副本！

+ 当 Redis Sentinel 被用于高可用并且 master 关闭持久化，这时如果允许自动重启进程，也是危险的！

+ 例如：

  master 可以重启的足够快，以至于 Sentinel 没有探测到故障，依旧会发生上述问题！

+ **任何时候数据的安全性都是重要的，所以如果 master 使用 复制功能的同时，没有配置持久化，那么自动重启进程应该是被禁用的！**