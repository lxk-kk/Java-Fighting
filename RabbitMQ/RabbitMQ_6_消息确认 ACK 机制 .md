#### 【RabbitMQ_6_消息确认 ACK 机制】

1. 什么是消息确认 ACK ？

   如果在消息处理的过程中，消费者的服务器在处理消息是出现异常，那可能正在处理的消息就没有完成消息消费，若不做处理，这条消息将会从消息队列中删除，导致数据丢失。为了保证数据不会丢失，RabbitMQ 支持消息确认-ACK

2. ACK 的消息确认机制

   ```xml
   <!--
   ACK 机制是消费者从 RabbitMQ 收到消息并处理完成后，反馈给 RabbitMQ ，RabbitMQ 收到反馈后才会将此消息从消息队列中删除。
   	1、如果一个消费者在处理消息时，出现网络不稳定、服务器异常等情况，那消费者服务器将不会有 ACK 反馈，此时RabbitMQ 将会认为该消息没有被正常消费，于是将该消息重新放入消息队列中！
   	2、如果在集群的情况下，RabbitMQ 会立即将该消息推送给这个在线的其他消费者。这种机制保证了在消费者服务端故障时，不会丢失任何数据！
   	3、消息永远不会被 RabbitMQ 从队列中删除，只有当消费者正确发送 ACK 反馈，RabbitMQ 确认收到消息后，消息才会从 RabbitMQ 服务器的队列中删除！
    	4、消息的 ACK 确认机制，【 默认是打开的！】
   -->
   ```

3. ACK 机制的开发注意事项

   ```xml
   <!--
   如果忘记 ACK 处理，后果将会很严重。
   当 Consumer 退出时，Message 会一直重新分发，返回 RabbitMQ 会占用越来越多的内存，由于 RabbitMQ 会长时间运行，因此这个“内存泄漏”是致命的！

   为什么致命？
   	因为没有收到 ACK 返回，该消息就不会从队列中删除，并且会一直重复的发送该消息到消费者服务端，这是一个死循环！一条消息没有发送成功，就会一直发送这条消息！
   	同时，消息队列并没有因为上述消息没有收到 ACK 反馈就停止接收消息，者会导致消息队列得不到处理，占用内存致使内存被占满，出现内存泄漏的现象！
   -->
   ```

4. 解决上述`内存泄漏`的现象【改动的是 Consumer 服务端】

   ```xml
   <!--
   1、在消费者处理消息的方法中，添加 try catch 捕获异常，当出现异常时，就在catch代码块中处理，使得消费者服务端能够正确返回 ACK 确认
   2、在配置文件中配置对于接收消息次数，即：失败重试的次数。当 RabbitMQ 运行时，若未接收到消息的 ACK 反馈，将会根据配置确定该消息重试的次数，达到重试次数以后，若还没有 ACK 反馈，则 RabbitMQ 将不会再发送该消息！
   -->
   ```

5. 配置失败重试

   ```xml
   <!--
   # 开启重试
   spring.rabbitmq.listener.retry.enabled = true
   # 配置重试次数：默认为 3 次（例如重试 5 次）
   spring.rabbitmq.listener.retry.max-attempts = 5
   -->
   ```
