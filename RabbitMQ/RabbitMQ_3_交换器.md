#### 【direct交换器】：发布与订阅：完全匹配

1. ##### 需求

   ![](material\8_direct交换器使用场景：日志处理.png)

   + 交换器类型：direct，对应匹配模式为：完全匹配

   + 交换器与队列之间通过 routing.key 进行匹配！

   + 项目服务分为：Producer 服务和 Consumer 服务

     Producer 服务为主系统：产生日志的地方

     Consumer 服务为 日志处理系统：处理日志信息的地方

2. ##### 配置

   1. Consumer

      ```xml
      <!-- 
      消息消费者：监听队列变化，当队列变化时，调用方法进行处理：@RabbitListener
      要实现监听队列就要绑定到具体队列，因此需要在bindings属性中设置如下内容
      	1、设置队列名称（要监听的队列）
      	2、设置交换器名称及类型 direct（由于队列中的消息来自于交换器，所以还需要设置交换）
      	3、设置路由键（队列与交换器进行绑定）
      通过 路由键 将绑定交换器与队列

      注意：@RabbitListener注解可以添加在 类上，也可以添加在方法上，当添加在类上时，需要指定类中的某个具体方法处理队列的消息，因此还需要使用@RabbitHandler在方法上进行指定！
      -->
      ```

   2. Producer

      ```xml
      <!--
      消息生产者：发送消息到指定的队列
      由于消息生产者与交换器进行通信，所以只需要设置交换器和路由键
      注入 RabbitAmqpTemplate rabbitAmqpTemplate bean，通过该 bean 的方法 convertAndSend 发送消息
      指定参数：
      	1、交换器名称（与指定的交换器进行通信）
      	2、路由键名称（由交换器将消息发送给我们指定的队列中）
      	3、消息
      -->
      ```

   3. 总配置

      ```xml
      <!--
      1、yml 配置文件中需要配置
      	rabbitmq 服务器的 ip
      	rabbitmq 服务器的 port
      	rabbitmq 服务器的 用户
      	rabbitmq 服务器的 用户密码

      2、不需要我们认为创建队列，MQ服务器会根据我们提供的 queue 名称自动创建队列，所以，不需要配置 Queue Bean，当然可以手动配置 Queue 的 bean。
      -->
      ```


#### 【Topic交换器】：主题：规则匹配

1. ##### 需求

   ![](material\9_Topic交换器使用场景：日志处理.png)

   + 交换器类型：Topic，对应匹配模式为：规则匹配

   + 交换器与队列之间通过 通配符`*`模糊 匹配，不需要直接写出 路由键完整的名称

   + 项目服务分为：Producer 服务和 Consumer 服务

     Producer 服务为主系统：产生日志的地方

     Consumer 服务为 日志处理系统：处理日志信息的地方

   + 使用场景

     ```xml
     <!--
     	当有多个 生产者服务 时，每个服务各自都会使用到多个队列，并且服务之间使用到相同的队列，此时，便可以使用 Topic 类型的交换器。
     	一个队列不需要和指定的生产者服务相绑定，该队列只需要和指定的处理主题相绑定（逻辑上绑定），各个生产者服务可以通过模糊匹配，将指定主题的消息存放入指定主题的队列中！然而，指定主题的队列，所存放的消息需要交由指定主题的消费者服务进行处理！（代码实现中：具体的模糊匹配实现在 消费者服务中 实现，生产者服务依旧需要提供完整的路由键）
     	一个生产者服务若匹配到多个队列，则消息将发送到这些队列中。
     -->
     ```

2. ##### 配置

   1. Consumer

      ```xml
      <!-- 
      消息消费者：监听队列变化，当队列变化时，调用方法进行处理：@RabbitListener
      要实现监听队列就要绑定到具体队列，因此需要在bindings属性中设置如下内容
      	1、设置队列名称（要监听的队列）
      	2、设置交换器名称及类型 Topic（由于队列中的消息来自于交换器，所以还需要设置交换）
      	3、设置路由键（交换器通过路由键中 通配符* 模糊匹配 到队列），路由键设置如下：
      		前缀匹配：topic*	：匹配到前缀为 topic 的队列
      		后缀匹配：*topic	：匹配到后缀为 topic 的队列
      		全匹配： *topic* ：匹配到 出现 topic  的队列

      注意：@RabbitListener注解可以添加在 类上，也可以添加在方法上，当添加在类上时，需要指定类中的某个具体方法处理队列的消息，因此还需要使用@RabbitHandler在方法上进行指定！
      -->
      ```

   2. Producer

      ```xml
      <!--
      消息生产者：发送消息到指定的队列
      由于消息生产者与交换器进行通信，所以只需要设置交换器和路由键
      注入 RabbitAmqpTemplate rabbitAmqpTemplate bean，通过该 bean 的方法 convertAndSend 发送消息
      指定参数：
      	1、交换器名称（与指定的交换器进行通信）
      	2、路由键名称（提供完整的路由键，交换器将该名称与所有队列进行模糊匹配，将消息送到匹配的队列中）
      	3、消息
      -->
      ```

   3. 总配置

      ```xml
      <!--
      1、yml 配置文件中需要配置
      	rabbitmq 服务器的 ip
      	rabbitmq 服务器的 port
      	rabbitmq 服务器的 用户
      	rabbitmq 服务器的 用户密码

      2、不需要我们认为创建队列，MQ服务器会根据我们提供的 queue 名称自动创建队列，所以，不需要配置 Queue Bean，当然可以手动配置 Queue 的 bean。
      -->
      ```

#### 【Fanout交换器】：广播：以广播的形式做消息传递，不需要匹配

1. ##### 需求

   【传统业务模型】

   ![](material\10_Fanout交换器使用场景：下订单_1.png)

   ```xml
   <!--
   ​	用户下订单后，需要向短信服务发送消息，同时需要向push服务推送消息，在传统设计模型中，这三个服务高度耦合，并且是同步操作，需要在订单服务平台调用短信服务和push服务平台的接口（紧耦合：不利于业务拓展，业务改变）
   -->
   ```

   【加入消息队列后的业务模型】

   ![](material\10_Fanout交换器使用场景：下订单_2.png)

   ​

   ```xml
   <!--
   ​	依旧是订单服务、短信服务、push服务三个服务平台，不同的是订单服务将不直接调用短信服务和push服务的接口，而是将请求交给中间件消息队列，由短信服务、push服务自动订阅队列中的请求。

   ​	要求订单服务的消息即传递给短信服务又传递给push服务，然后这两个服务不能共用同一个队列，此时就可以通过交换器以广播的方式将消息传递个这两个队列。

   ​	fanout 类型的交换器能保证，传入交换器的消息将同步传递到同一个虚拟主机的所有队列中，这样以来，相应的服务平台只要订阅了相应队列，就能接收到订单服务发送的消息。

   ​	这样完全是一个松耦合的设计，生产者与消费者之间不需要直接交互，而是通过 RabbitMQ 进行间接通信。
   -->
   ```
2. ##### 配置

   1. Consumer

      ```xml
      <!-- 
      消息消费者：监听队列变化，当队列变化时，调用方法进行处理：@RabbitListener
      要实现监听队列就要绑定到具体队列，因此需要在bindings属性中设置如下内容
      	1、设置队列名称（要监听的队列）
      	2、设置交换器名称及类型 Fanout（由于队列中的消息来自于交换器，所以还需要设置交换）
      【注意】：去掉路由键，路由键的作用就是通知交换器将消息传递到指定的队列中，由于广播模式，消息将传递倒是所有队列中，因此路由键便不需要存在。如果要加上路由键，那就不是广播模式了，而是将消息传递到指定的队列中，而并不是让消息传递到所有队列中

      注意：@RabbitListener注解可以添加在 类上，也可以添加在方法上，当添加在类上时，需要指定类中的某个具体方法处理队列的消息，因此还需要使用@RabbitHandler在方法上进行指定！
      -->
      ```

   2. Producer

      ```xml
      <!--
      消息生产者：发送消息到指定的队列
      由于消息生产者与交换器进行通信，所以只需要设置交换器和路由键
      注入 RabbitAmqpTemplate rabbitAmqpTemplate bean，通过该 bean 的方法 convertAndSend 发送消息
      指定参数：
      	1、交换器名称（与指定的交换器进行通信）
      	2、不需要路由键，设置成空串""即可（将路由键设置成空串，使得消息能够广播道所有队列中）
      	3、消息
      -->
      ```

   3. 总配置

      ```xml
      <!--
      1、yml 配置文件中需要配置
      	rabbitmq 服务器的 ip
      	rabbitmq 服务器的 port
      	rabbitmq 服务器的 用户
      	rabbitmq 服务器的 用户密码

      2、不需要我们认为创建队列，MQ服务器会根据我们提供的 queue 名称自动创建队列，所以，不需要配置 Queue Bean，当然可以手动配置 Queue 的 bean。
      -->
      ```

