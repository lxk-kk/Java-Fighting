### 操作系统

+ [内存、外存、缓存](https://www.jianshu.com/p/610acafd01fe)
+ [内存、外存、缓存、高速缓存](https://blog.csdn.net/qq_38998213/article/details/87908836)

#### 进程管理

##### 进程 & 线程

+ 进程是指 具有 独立功能的程序 在某个数据集上的一次运行活动！它是资源分配的基本单位！

  在 java 中，通过执行 main 方法就能启动一个进程！

+ 线程 是比进程更小的 运行单元，是 CPU 调度的基本单位，可以视为 轻量级 的进程！

  在 java 中，执行 main 方法的，就是进程中的 主线程！

+ **进程 vs 线程**

  1. 进程是**资源分配**的基本单位，是资源的拥有者！

     线程属于进程，是 CPU 调度的基本单位，它不拥有资源，它只使用 所属进程的资源！

  2. 进程之间**相互独立**，不共享资源，各个进程有自己 独立的 虚拟机地址空间！

     线程 与 所属进程下的 其他线程 共享进程的 虚拟地址空间，也就共享 进程的资源！

  3. 进程的**上下文切换** 比 线程 开销大。

     因为，进程相互独立，切换时，系统必须要交换地址空间！

     而，进程内的线程，共享进程的 资源空间，就不涉及相关的资源信息保护 和 地址空间变化！

  4. 线程之间的**通信** 相较于 进程通信 要更加容易！

     通信 就是 进程或线程之间 进行数据交换的过程：由于 同一个进程下的线程 共享同一个地址空间，所有的全局数据都可以访问，不需要特殊的手段！而，进程之间的通信则相对复杂！

  5. 正是因为线程的轻量级，并且不持有资源，因此 进程内部可以 建立大量的线程。而操作系统中 进程 的**个数**有限，远远少于 线程！

+ **协程**

  ```java
  /*
   · 协程更轻量的线程，它工作在 用户态，能够在用户态产生中断并转而执行其他的程序！
   · 协程的上下文切换由程序控制，并不由内核控制，在上下文切换时，并不需要内核态的支持！
   · 因此，协程 比 线程更加高效！
  */
  ```

+ **程序**

  **程序只是一组指令的有序集合，它本身没有运行的含义，它只是一个静态的实体。**

+ JVM  中的 线程和进程


##### 系统调用

###### CPU 特权级

+ CPU 将特权分为4个级别：**Ring0、Ring1、Ring2、Ring3**

  ```
   · Ring0 是最高级别，有关安全性的指令 都被限制在了 Ring0 级别，包括：内存清理、置时钟、分配系统资源、修改虚拟存储的段表和页表、修改用户访问权限等。
   
   · 如果这些指令被特权低的用户程序执行，那可能会引起系统混乱，甚至崩溃！因此 Ring0 级别的指令只能被 操作系统内核使用，不能被其他应用程序执行，用户程序只能执行低级别的指令！
  ```

  [CPU 运行环、特权级 与 保护](https://blog.csdn.net/drshenlei/article/details/4265101?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1)

+ Linux 操作系统就利用了 CPU 特权分级的特性，*应用了其中的 0级和3级*。

  + **Linux 内核态：0级别**：内核可以执行所有指令，访问所有的内存空间

  + **Linux 用户态：3级别**：用户只能执行非特权指令

    ```
    用户态如果想使用特权指令，则需要 产生中断，将请求交给 内核态 来完成，这是唯一途径！
    ```

  [Linux系统整体架构：用户态 vs 内核态](https://baijiahao.baidu.com/s?id=1637922221053576019&wfr=spider&for=pc)

+ 这样的的分级使得系统非常稳定安全。

###### 中断

+ **中断**

  ```
   · CPU 在执行 程序的过程中，由于某种外部或者内部 异步事件的作用，使得 CPU 停止当前正在执行的程序，保存现场后自动转去执行相应的处理程序，处理完后返回断点，继续执行被打断的程序！
  ```

+ **中断处理**

  ```
  1. 保存现场
  2. 执行中断处理子程序
  3. 中断返回，恢复现场
  ```

+ **硬中断 & 软中断**

###### 进入内核态

+ **为什么和内核态打交道，效率低？**

  ```
   · 在用户态产生的任何系统调用，都需要转向内核态来完成，由用户线程 切换为 内核线程！
   	这两种状态的转换开销，主要来自于 响应中断、保护 和 恢复执行现场的程本！
   	
   · 内核函数的调用：socket网络上的读写，对于 1:1 线程模型而言，启动、唤醒、阻塞、杀死线程 等线程操作都需要产生系统调用！
  ```

+ **用户态 -> 内核态** 

  1. *用户程序发出 0x80中断 或者 调用sysenter原语*

     ```
     以前的CPU：通过软件产生软中断80中断
     最新的CPU，在硬件上做的支持，提供 系统调用原语，通过这个原语就可以直接切换到内核态
     ```

  2. *操作系统 保存 现场*

     ```
     （1）保存硬件现场：CS、IP等寄存器的值（CS：代码段寄存器，IP：指令指针寄存器）
     （2）保存用户线程状态：堆栈和寄存器中的值（方法调用过程中的 各种变量 和 资源）

      上述这些信息都将保存到 栈 中！
     ```

  3. *CPU 查找中断处理子程序 并 执行*

     ```
      · 根据中断类型码，在中断向量表中查找 所对应的中断服务子程序！
     	即：寻找处理 中断值为0x80 的中断处理子程序的入口地址，就是 system_call 中断处理子程序！
     	
      · 执行中断服务子程序，将返回值放在eax寄存器中
      	即：执行 system_call 中断处理子程序
     ```

  4. *返回用户态，恢复现场*

     ```
     用户态程序读取出返回值，同时将之前保存在栈中的数据取出，恢复现场
     ```

  5. *用户程序继续执行*

+ **保存现场 和 恢复现场 免不了一系列数据在各种寄存器、缓存中来回拷贝，这当然是一个耗费时间的过程！**

##### 进程通信

+ 进程之间 相互独立，拥有不同地址空间，资源不共享！

+ 要想在进程之间交换数据，就需要在内核中开辟缓冲区，将 某个进程中数据 拷贝到 缓冲区中，其他进程再取走！

+ 通信方式：[进程通信总结](https://www.jianshu.com/p/c1015f5ffa74)

  1. **管道/匿名管道（pipe）**

     管道实质是 内存中的特殊文件，只支持半双工通信，并且只能在 父子进程、兄弟进程 中使用！

     如果要实现全双工，则使用两个管道！

  2. **有名管道（FIFO）**

     ```
     匿名管道 没有名称，因此只能用于 父子进程 和 兄弟进程 之间！为了克服 只有亲缘关系的进程 才能够通信，出现了 有名管道！
     ```

     有名管道 本质是磁盘文件，与路径名相关！不同的进程之间，只要能访问 管道名 就能 实现通信，而不再受限制于 有亲缘关系！能够实现本机中任意两个进程的通信！

     ```
     对于管道而言，无论有名还是匿名：都在 先进先出的 规则下进行读写，且都是 半双工通信！
     ```

  3. **消息队列**

     消息队列 中写数据的进程 称为 消息生产者，而获取数据的进程称为消息的消费者，它独立于 读写进程 而存在！

     ```
     消息队列 vs 有名管道 
      · 相同点：一样都按照 先进先出 规则进行读写！
      · 不同点：
     	1. 在有名管道打开时，必须保证通信双方的存在，否则将阻塞！而消息队列，独立于 读写进程，不会因为通信双方的存在与否而阻塞！
     	2. 有名管道中，读进程只能默认接收数据！而消息队列中，消费者进程可以选择性消费！
     ```

  4. **信号（signal）**

     信号是一种进程通知机制，它能在任意时刻通知目标进程，表示某个事件已发生，而无需知道进程的状态！

     ```
     例如：
     Linux 中的 kill -9 指令发出 SIGKILL 信号，表示终止进程！
     键盘设备的 Ctrl+C 发出 SIGINT 信号，表示程序终止！
     ```

  5. **信号量（Semaphore）**

     信号量 是一个非负整数 表示的 计数器，用于多进程中共享资源的访问，实现进程之间的同步操作！

     ```
     互斥量：用于进程之间互斥资源的访问 —— 进程间的 互斥！
     信号量：用于进程之间共享资源的访问 —— 进程间的 同步！
     ```

  6. **共享内存**

     共享内存 允许 多个进程共同读写同一个块内存空间，共享数据不需要在进程之间复制，是最快的一种进程通信方式！

     由于允许进程直接对共享数据进行读写，因此，需要依靠某种同步机制（例如：信号量、互斥量）实现进程间的同步或者互斥！

  7. **套接字**

     套接字是 TCP/UDP 的对外接口，用于实现客户端和服务端之间的网络通信！

##### 进程状态

![](image\进程的 5 态模型.jpg)

1. 创建态：进程从无到有的过程，会分配所需的资源！
2. 就绪态：进程待在就绪队列中，等待 CPU 调度！
3. 运行态：就绪态的进程 得到 CPU 处理时间，便进入运行态！
4. 阻塞/等待：正在运行的进程 需要等待资源被释放、等待 IO结束、等待某事件的发生（例如：其他进程的输入）！
5. 终止态：进程正常执行完毕、进程被异常终止等！

##### 进程调度

###### 批处理系统

+ 批处理系统 基于 “批量处理”，将作业成批装入 计算机，由操作系统为其创建进程，并按照某种调度算法选择 一道 或者 几道作业 装入内存运行！

+ **调度算法**

  1. **先来先服务**算法（FCFS：First Come First Serve）

  2. **短作业优先**算法（SJF：Short Job First）

  3. **最短剩余时间优先**算法（SRTF：Shortest Remain Time First）：抢占式

  4. **最高响应比**算法（HRN：Highest Response Ratio Nex）

     ```
     响应比 = 作业周转时间 / 作业处理时间

     作业周转时间：作业被加载到内存 到 作业执行完成 之间的时长！
     ```

  5. **最高优先级**算法（HPF：Hightest Priority First）

     ```
     用户规定优先级、系统计算优先级
     ```

  6. **均衡调度**算法（**分类排队**算法）

     ```
     按照某个划分标准（作业长度、作业计算量/IO量），将作业分类，轮流从作业类中挑选作业！
     ```

+ 批处理系统 提高了 资源利用率 与 系统吞吐量！

###### 分时系统

+ 分时系统 是指 一台主机 能够与 多个终端相连，并采用 *分时技术* 为终端提供服务！

  每个 终端 执行一定的分时时长后，将 CPU 交给下一个 终端 处理，使得 CPU 能够同时为 多个终端提供服务，并且，能够及时响应终端请求！

+ 分时系统没有 作业调度 的概念：

  分时系统中，为了缩短响应时间，作业 会直接输入到内存，并为其分配资源 创建进程，加入到就绪队列中，与其他进程一起抢占处理机资源！而不必将 作业输入 外存的输入井，也就没有了作业调度！

+ **调度算法**：

  1. **时间片轮转调度**算法

     ```
      · 按照 FCFS 的原则，为每个进程分配 一定的时间片 占用 CPU。
      · 当时间片 执行完后，计时器会触发时钟中断，调度程序便将 进程 加入到就绪队列的末尾，等待再次分配时间片！
     ```

     ```
      · 注意：时间片的大小 与 算法的执行效率有很大关系：
      	1. 时间片过长，无法保证及时响应终端！
      	2. 时间片过短，进程上下文切换会过于频繁，上下文切换会占用处理机资源，切换过于频繁，会导致效率大大降低！
     ```

  2. **优先权调度**算法

     ```
      · 为每个进程分配一个优先级，优先级高的进程优先占用 处理机 资源！
     	为避免低优先级的线程永久等待，调度器会 进程等待的时长 动态改变优先级！
     	进程等待的时间越长，优先级会越高！
     	
      · 通过优先级的动态判断，能够有效的控制 进程占用 CPU 的时长，达到分时的效果！
     ```

  3. **多级反馈队列**调度

     多级反馈队列 是 *时间轮转调度 和 优先权调度的 综合体* ！

     + 多级反馈队列 设置了**多个 就绪队列**，队列拥有 **优先级 和 时间片**两个属性，每个就绪队列的优先级不同，**优先级越高的队列，分配的时间片越小**！
     + **进程首先会进入 优先级最高的队列**，队列按照 **FCFS规则**，每次取出一个 进程执行！**若时间片执行完后，进程还未结束，则将进程排入下一个队列的末尾！**
     + 相对于低优先级队列，**高优先**级队列中的**进程 会优先执行**！若高优先级队列中出现 新进程，那么调度器会暂停当前正在执行的进程，转而执行 高优先级队列的进程，而被暂停执行的进程将被加入到 当前队列的末尾，等待下一次调度，下一次调度时，会接着剩余的时间片执行！
     + 对于 **优先级最低 的就绪队列**，调度器会采用 **时间片轮转的算法** 进行调度，若队列在指定的时间片内未执行完毕，则加入到该队列的 末尾，等待下一次调度！并且，**只有当前面的队列中没有进程等待执行时，才执行 此队列中的进程！**

     多级反馈队列算法 能够很好的平衡 短作业 和 长作业的 执行效率！

     对于 IO型进程，通常只需要很短的执行时间，在高优先级就绪队列中就能执行完成；对于 计算型进程，通常会在 低优先级队列中 长时间执行。能够有效的提高系统的吞吐率，同时，对于长作业，随着优先级的降低，进程切换的次数就会变少，能够有效降低上下文切换的消耗！

##### 处理器调度

+ 处理器调度 分为 3 个层次：高级调度、中级调度、低级调度！

###### 高级调度

+ **高级调度（作业调度）**

  高级调度：是指 *按照某种算法 从外存 的后备作业队列中 挑选一个或者 多个作业，为其创建进程，并分配资源！*

  ```
   · 后备作业队列（输入井）：
   	是 高速磁盘（外存）的一部分空间，用于缓解 内存 与 IO设备 之间速度不匹配的问题：I/O 设备较为 低速，因此，操作系统会将 IO设备的作业 输入到 输入井中，等待被加载！
  	同时，由于操作系统内存有限，某些时刻 无法将 用户提交的所有作业 都加载到内存中，后备作业队列也缓解了内存紧张的问题！ 	
  ```

###### 中级调度

+ 中级调度 是为了 提高内存的利用率 和 系统的吞吐量。

  内存中的进程有限，多余的进程 需要移到 外存中，当内存中有足够的空间时，再将合适的进程 换入内存，等待进程调度！

+ *中级调度 是将 进程挂起 的过程，也是激活 挂起进程 的过程！*

  ```
  进程的 七态模型 相对于 五态模型，多了 等待挂起 和 就绪挂起 这两个状态！
  · 等待挂起 激活后 只能是 等待状态！
  · 就绪挂起 激活后 只能是 就绪状态！
  ```

###### 低级调度

+ **低级调度（进程调度）**

  *按照某种算法 从就绪队列中 选择一个 进程，将 CPU 分配给该进程！*

+ 低级调度 进程从 就绪态 到运行态的过程！

##### 死锁

###### 死锁介绍

```java
/*
 · 死锁
 	两个或多个进程相互请求对方所持有的资源，若无外力作用，它们将无法推进下去。此时称系统处于死锁状态或者系统产生了死锁！
 	（操作系统中的定义：系统中两个或者多个进程无限期地等待永远不会发生的条件，系统将处于停止状态，这种现象称为进程死锁，这一组进程称为死锁进程）
 
 · 死锁具备的四个条件
 	1、资源互斥：一个资源每次只能给一个进程使用！
 	2、不可剥夺条件：进程持有的资源，不可被其他进程强行剥夺，只有自己使用完毕才会释放资源
 	3、请求与保持：一个进程因请求资源而阻塞时，对已获取的资源保持占有！
 	4、循环等待：进程之间形成环状的资源等待关系！
*/

/**
 * 死锁示例
 * @author 10652
 */
public class DeadLockTest {
    private static Object resource1 = new Object();
    private static Object resource2 = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            // 资源1
            synchronized (resource1) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource2");
                // 持有资源1 请求资源2
                synchronized (resource2) {
                    System.out.println(threadId + " : request resource2 successfully");
                }
            }
        }).start();
        new Thread(() -> {
            // 资源2
            synchronized (resource2) {
                long threadId = Thread.currentThread().getId();
                System.out.println("current thread " + threadId);
                System.out.println(threadId + " : hold the resource2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(threadId + " : try request the resource1");
                // 持有资源2 请求资源1
                synchronized (resource1) {
                    System.out.println(threadId + " : request resource1 successfully");
                }
            }
        }).start();
    }
}
// 输出结果：
current thread 13
13 : hold the resource1
current thread 14
14 : hold the resource2
13 : try request the resource2
14 : try request the resource1
```

###### 死锁检测工具

1. jConsole 工具

   ```java
   /*
    · idea命令行 》jConsole

    · jConsole 工具
    	jConsole 是 JDK 自带的监控工具，用于连接正在运行的本地或者远程 JVM，对运行在 Java 应用程序的资源消耗和性能进行监控，并通过可视化界面的方式展现！
     · 如下图：检测上述程序的死锁！
   */
   ```

   ![](C:/Users/10652/Desktop/Fighting/temp_over/并发/image/死锁_1.png)

   ![](C:/Users/10652/Desktop/Fighting/temp_over/并发/image/死锁_2.png)

2. jstack

   ```java
   /*
    · idea 命令行 》jstack 进程ID

    · jstack 是虚拟机自带的一种堆栈跟踪工具，用于打印给定的 java进程ID 或者 core file 或者 远程调试服务的 java堆栈信息！
    
    · jstack 工具可以用于生成 java虚拟机当前时刻的线程快照。
      线程快照是当前 java虚拟机 内每一条线程正在执行的方法堆栈的集合，生成线程快照主要是为了定位线程出现长时间停顿的原因！例如：线程间死锁、死循环、请求外部资源导致的长时间等待等！
      线程停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在做什么，或者在等待什么资源！
     · 如下图：检测上述死锁进程程序：
   */
   ```

   <img src="、image/死锁_3.png" style="zoom: 67%;" />

###### 解决死锁

1. **鸵鸟策略**

   把头埋进沙子里，**当作什么都没发生**！

   **解决死锁的代价比较高**，因此**鸵鸟策略**这种不采取任何措施的方案会获得 **更高的性能**。

   如果发生死锁时，*不会对用户造成大影响*，或者 *发生死锁的概率很低* 的话，那么就可以采用鸵鸟策略！

   大多数操作系统，例如Unix、Linux、Windows 处理死锁的方式仅仅是忽略它！

2. 死锁**预防**：破坏死锁的四个条件之一！

   + 破坏 **不可剥夺条件**：主动释放资源

     若进程*申请资源失败时，主动释放自己持有的资源*，需要时再次获取！

   + 破坏 **请求与保持**：一次性获取全部资源

     在*进程运行之前，一次性申请全部运行所需的全部资源*，只有当进程申请的资源得到满足，采给予一次性分配！

   + 破坏 **循环等待**：统一顺序获取资源

     将*资源进行编号，进程必须统一按照编号顺序获取资源* ！

   + 互斥条件：例外：加锁的目的就是资源的互斥访问！

3. 死锁的**避免**

   在程序运行过程中，**对进程发出的资源申请进行动态检测，判断分配资源后，系统是否可能产生死锁**！

   典型的算法：银行家算法！

4. 死锁的**检测**

   ```java
   /*
    进程 - 资源分配图（有向图）：判断是否有死锁发生！
    MySQL 中也使用了 资源分配图检测死锁，不过稍有不同！
   */
   ```

   ```
   资源分配图的简化：
    1. 找一个只有分配边的 非孤立结点，去掉分配边，将资源分配给资源的请求边！
    2. 循环做上面这个动作，当图中的所有进程都变成孤立结点，则说明无死锁！
   	如果存在无法化简，说明存在环，也就存在死锁！ 
   ```

   ![](image\进程资源分配图.jpg)

5. 死锁的**解除**

   + 资源剥夺法：发现死锁后，**从其他线程中剥夺足够的资源**分配给死锁线程，以解除死锁状态！
   + 撤销进程法：发现死锁后，**撤销所有死锁进程**！（MySQL 按照 FIFO 的方式部分或者全部回滚一个事务）

#### 内存管理

##### 分区存储

+ 分区管理 是为 进入内存的 用户作业（进程）划分一块连续的存储区域，把作业转入该连续的存储区域中！每一个内存区域称为分区！
+ 根据分区 的时机不同，可以将分为 固定分区 和 可变分区！

###### 固定分区

+ 固定分区又称为 定长分区 或者 静态分区

  在操作系统启动时，将内存空间划分为 若干个 固定大小的分区，分区大小可以全部一样，也可以不相等！

###### 可变分区

+ 可变分区 又称为 边长分区

  在作业载入内存后，按照作业的大小动态分配内存空间！

+ 内存分配算法：

  可变分区导致 内存中的空闲区不止一个，作业申请内存空间时，需要为其选择一块空间！

  1. **首次适应**算法：每次从**空闲区开始地址**，**地址递增**查找
  2. **循环首次适应**算法：从**上一次分配的空闲区地址**的下一个地址开始，**地址递增**查找
  3. **最佳适应**算法：将空闲区**容量按照升序排列**，从头开始查找
  4. **最坏适应**算法：将空闲区**容量按照降序排列**，从头开始查找

+ 内存释放算法：

  作业释放后，合并相邻空闲区！

+ 分区移动技术：

  当连续的空间不足以为大作业分配内存时，移动正在执行的作业内存，将碎片的内存空间合并成一个大空间，为新作业分配内存！

+ 覆盖 与 交换技术

  多道环境中，用来扩充内存的两种算法！

##### 页式存储

+ 分区存储 直接将一份连续的内存区域分配个进程，导致 内存浪费、内存碎片 的问题！于是出现了 页式存储管理，*页式存储 借助 逻辑地址，使得能在 物理地址不连续的 内存中为 进程 分配空间*，**提高了内存空间的利用率**！

+ 地址划分：

  + 内存空间：划分为 若干个长度相等的 块，每个块 称为*页框* ！

  + 程序的逻辑地址空间：按照页框的大小，划分成多个*页面（页）*，不足一页的部分补齐为一页！

    页中某一段程序的 **逻辑地址格式**（**页号 : 页内地址**）

+ 页式存储管理 在进程启动之前，会将进程的程序段和数据，按照页面，全部装入内存的各个页框中！同时为每个进程分配一个**页表**，用于存储 **页面号 与 页框号的映射**关系！

  通过页表，使得连续的逻辑地址 可以分配在 不连续的内存块中！

  页中某一段程序的 **物理地址 = 页框号*页框大小 + 页内地址**

+ *地址变换* ：动态重定位技术

  ```
  请求表：存储各个进程 请求的页面数、进程页表的起始地址、页表的长度、分配状态等信息！
  页表控制 寄存器：存放当前运行进程的 页表起始地址 和 页表长度，以加快地址转换速度！（寄存器中）
  页表：页面号 与 页框号 的映射关系！（内存中）
  ```

  当选中进程运行时，系统首先从 请求表中 取出进程相关的 页表起始地址 与 页表长度，存入 页表控制寄存器中！

  ****

  地址转换时（访问数据），根据寄存器中 页表的位置 以及 逻辑地址中的 页面号，查找页表，得到对应的页框号！

  最后由 硬件 完成物理地址的计算：**物理地址 = 页框号*页框大小 + 页内地址**

  ```
  进程执行的过程中，若处理器需要访问内存中的操作数，则需要两次访问内存：
  1. 根据寄存器中的 页表地址 访问页表！
  2. 计算出物理地址后，真正的对 内存 中的操作数读写！
  ```

+ *快表* ：**只需一次访问内存**

  上述 CPU 访问操作数，需要两次操作内存，耗时较长，而 快表 正是用于缩短操作数从访问时长！

  快表 是 具有 **并行查找能力的** **高速寄存器组**，也称为 *相联存储器* ！它能实现**按照内容查找**，存放着当前访问最为频繁的 少量 活动页表项！

  ```
  快表 类似于 具有并行查找能力的高速寄存器缓存，存储的是 频繁访问的 页表！
  地址转换时，直接在快表中查找 页面号，得到对应的 页框号！

  快表的管理 与 缓存的管理 一样：存在则使用，不存在则刷新快表，多余则淘汰！
  ```

+ 页式存储 使用 **位示图** 记录页框的**分配情况**！

+ **多级页表 和 反置页表** 是，在进程的逻辑空间不断变大时，减少内存空间开销的 两种方式！

  *因为进程的逻辑空间不断增大，意味着 页表占用的空间也会不断增大，耗费内存！*

##### 段式存储

+ 段式管理 **将进程空间 划分为多个段**，每个段定义一组逻辑信息（例如：主程序段、子程序段、数据段 及 工作区段等），并**以段单位分配内存**，访问通过地址映射机制 将段式的逻辑地址转换为物理地址。

  每个段都是从 0 开始编制，段长度 由 内部定义的逻辑信息单位的长度决定，并且段间地址不连续，段内地址连续！

+ 段的**逻辑地址形式=段号:段内地址**

+ 段式存储中的地址定位原理相同，每次访问数据都需要两次访问内存，同样可以使用 *相联处理器* 优化地址定位！

  ```
  段表：存放在内存中，每个进程都会分配一个段表，存储 进程中的 段 和 段长度 的映射关系！
  段表 控制寄存器：存储 段表的起始地址 与 段表长度！
  ```

+ 分区内存分配/释放 在 为段分配内存/释放内存 时同样适用！

+ **共享段**

  正是因为 段的划分具有逻辑意义，并且段拥有段名，因此，可以实现多个进程之间共享某个段！

  为此，系统还需要 建立一张 **共享段表**，用于记录共享段的信息 以及 共享此段的进程信息！

  <img src="image\共享段.jpg" style="zoom: 25%;" />

+ 段保护

  1. *越界检查*

     ```
     根据段表，对段的逻辑地址检查：
      1. 检查逻辑地址 段号 是否越界（段表的长度）
      2. 检查逻辑地址 偏移地址 是否越界（段表中段的长度）
     ```

  2. *存取控制检查*

     段表中的每个段 设置了 该段的访问控制字段，包括：只读、只执行 和 读写权限！

     这在共享段中尤为重要，根据进程的访问权限 能够 保证段信息的安全性！

  3. *环 保护机制*

     系统将 进程执行 划分为多个等级：

     + 最高级 0 级：具有最高的特权，属于操作系统的内核，能够访问所有的段 和 页面。

       只有 内核进程 能够执行 特权指令，用于  I/O管理、存储管理、进程管理等 危险功能。

     + 1级：是一些 实用程序 和 操作系统服务，例如：系统调用管理程序等！

     + 2级：是共享库 的 过程和函数！

     + 3级：一般的应用程序！

     一个进程限制 自己访问相同的 等级或者 较低级 中的 段和数据，需要访问 较高级 的段和数据时，必须采用系统调用的形式！

     Linux 操作系统 便应用其中的 0级 和 3级：

     + 0级：内核态：可以访问所有的内存空间！
     + 1级：用户态：只能访问 用户内存空间！

##### 段式 vs 页式

+ 相同点：

  1. 段式 和 页式 都用于 减少内存碎片，提供内存利用率！
  2. 段式、页式 都是离散分配内存的，但每个 段和页 内部都是连续的！

+ 不同点：

  1. 页的大小固定，并且由操作系统决定；分页仅仅是为了 满足 操作系统的内存管理需求！

  2. 段是具有 逻辑信息的单位，大小 由进程中的程序和数据决定，并不固定；分段是为了更好的满足用户需求！

     ```
     数据段、代码段、工作区段：更好的满足 开发人员？
     ```

##### 段页式存储

+ 段页式存储管理 结合了 段式管理 和 页式管理的优点。

  **它用段式存储管理程序地址，用页式存储管理内存地址，即：将进程空间划分为多个段，每个段又由多个页组成！**

+ 这种方式，既能够满足上层的用户需求，又能够满足底层的操作系统的内存管理需求！

  ```
  分段 使得程序的内存划分变得有意义，而，分页 使得操作系统提高内存利用率，减少内存碎片，两全其美！
  ```

+ 段页式**逻辑地址**：**段号:段内页号:页内偏移地址**

+ 段页式**地址映射表**：**段号:页表地址:页表长度**

##### 虚拟存储

###### 介绍

+ 页式、段式、段页式 三种存储管理，都是将 进程的程序和数据 一次性装入 内存中，但是某个时刻只需要使用到某一段程序，而非所有，这就导致了不必要的内存占用！

+ 虚拟存储管理实现了 某个时刻只需要 载入进程正常运行的必要程序/数据，而非全部载入！但是对于 进程而言，却有一种 自己已经在内存中分配了 足够连续可用的内存空间 的感觉！

  ```
  目的：
  能够在内存中建立更多的进程，增加系统的并发量，使得在 提高内存利用率！

  应用：
  目前大多数操作系统都使用了虚拟内存的技术：windows家族的“虚拟内存”，Linux的“交换空间”等！
  ```

###### 局部性原理

+ 局部性原理

  是指 *CPU 对指令和数据的存取，在 时间、空间 或者 顺序 上往往集中在一定的范围内！*

+ 经研究表明：**程序的执行 也具有 局部性规律，也就是说，在某个较短的时间内，程序的执行局限于某个部分，程序访问的存储空间也局限于某个区域！**

+ 局部性原理表现三个方面：

  1. **时间 局部性**：当前正在执行的指令 或者 正在访问的数据，在不久后，可能会被再次 执行 或 访问！

     ```
     指令上：程序的循环、递归等
     数据上：堆栈
     ```

  2. **空间 局部性**：若某个 存储单元 被访问，那么不久后，其临近的存储单元 也会被访问到！

  3. **顺序 局部性**：通常情况下，除了转移指令外，大部分指令是按照 地址连续 执行的！

     ```
     指令上：指令的顺序存放、顺序执行
     数据上：数组
     ```

+ 正是由于程序的执行存在 局部性规律，进程执行时，只需要按照 局部性原理 载入 程序和数据，就能保证进程在一段时间的正常执行！

  + 对于 时间局部性

    采用 *缓存* 机制，缓存 当前的访问数据/执行的程序，以备不时之需！

  + 对于 空间局部性、顺序局部性

    采用 *预读+缓存* 机制，将当前访问的指令/数据 临近的 指令/数据 载入内存，并缓存，以备不时之需！

###### 虚拟存储器

+ 虚拟存储器

  **它是 操作系统 为用户提供的 虚拟内存，让用户进程认为 自己在内存中分配了 足够 连续可用的空间！**

+ 实现原理：

  > 基于程序运行的 局部性原理，操作系统会将 需要访问的 程序/数据 存放在内存中，而其余大部分存放于 磁盘中！
  >
  > + 若进程访问的 信息 不存在于内存中时，就需要从磁盘装入 —— 部分装入！
  >
  > + 若内存容量已满，就需要将内存中暂时不用的 信息 对换到磁盘中 —— 部分对换！
  >
  > 通过 程序执行的需要 以及 内存的实际使用情况，采用 部分装入、部分对换 技术，能够为用户提供比实际内存空间大的多存储器。`容量取决于磁盘，速度取决于内存，两者兼得！`

+ 实现方式：

  1. `请求页式存储管理`

     以页式存储管理为基础，以页为单位，实现 数据/程序 的请求与调换！

  2. `请求段式存储管理`

     以段式存储管理为基础，以段为单位，实现 数据/程序 的请求与调换！

  3. `请求段页式存储管理`

     以段页式存储管理为基础，以页为单位，实现 数据/程序 的请求与调换！

  ```
   · 无论哪种实现方式，都有需要：
  	1. 一定的容量的内存 和 外存：进程执行时，只需要载入程序的一部分，其余部分留在磁盘中！
  	2. 缺页中断：如果执行的 指令/数据 不存在于 内存中时（缺页/缺段），则从 磁盘中调入所缺内容，如果内存满了，则 淘汰暂时不用的 内容！
  	3. 虚拟地址空间：逻辑地址到物理地址的变换！
  ```

###### 缺页中断

+ 请求页式管理中，每当所要访问的页不存在于 内存中时，就会产生缺页中断，请求操作系统将所缺的页面调入内存中！

+ 缺页中断作为中断，它同样需要经历如下步骤：

  1. 保护 CPU 环境
  2. 分析中断原因
  3. 转入 （缺页）中断处理程序 进行处理
  4. 恢复 CPU 环境，进程继续执行！

+ 缺页中断 与 普通的中断有着明显区别：

  1. 在指令执行期件产生 和 处理中断信号！

     ```
     一般的中断都是在 指令执行之后判断是否产生中断，有则响应中断，没有则继续执行！
     在指令执行期间，如果发现进程所要访问的指令或者数据不存在时，就需要处理缺页中断！
     ```

  2. 一条指令执行期间，可能产生多次缺页中断！

###### 页面置换算法

+ 发生缺页中断时，如果内存空间满了，就需要 按照某种算法将 内存中暂时不用的 页面 置换出去！

  页面置换算法的选择直接影响了系统的性能，不适当的算法会频繁的发生页面置换，使得进程将大量时间耗费在页面置换上，而发生“抖动”、“颠簸”！

  页面置换算法 的目标在于：将来不发生缺页中断，或者尽量少的缺页中断！

****

1. **先进先出（FIFO）** 置换算法

   ```
    · FIFO置换：将最先进入内存的页面，置换出去！

    · 缺点：
   	1. 置换策略 与 进程实际的运行规律 不适应，可能会将经常被访问的页面置换出去，从而缺页率升高，性能下降！
   	2. 可能会出现 Belady 现象：进程分配的页框越多。缺页率反而越高！
   ```

2. **最近最久未使用（LRU）** 置换算法

   ```
    · LRU置换：选择最近一段时间内 最久没有被访问过的页面，置换出去！
   	
    · 算法赋予每个页面一个访问字段，用来记录该页面，自上次被访问以来所经历的时间 T，需要置换页面时，就选择现有页面中 时长T 最大的页面，即为最近最久未使用的页面！
   ```

3. **时钟（Clock）** 置换算法

   ```
    · 将内存中所有的页面 按照访问的先后顺序，链接成 环形队列，并为每页设置一个访问位；
    	初始时刻，被访问的页，其访问位都会置 1；
    	当需要置换页面时，会遍历 环形队列，若某页的访问位为1，则将其置0（表示本次未被访问到），进入下一页；若某页的访问位为 0（说明，这是最近未被访问到的），则将其置换出去！
    	
    · 时钟置换算法 也称为 最近未使用算法！
   ```

4. **最少使用（LFU）** 置换算法

   ```
    · LFU置换：在现有页面中，将访问次数最少的页面 置换出去！
    · 算法为 内存中的所有页面都设置了访问计数器，用来记录该页面被访问的次数，页面被访问时，计数器加1，置换页面时，选择计数器值最小的页面置换出去！
   ```

5. **最佳（OPT）** 置换算法

   ```
    · OPT置换：选择 将来永久不使用 或者 在将来最长一段时间内不再被访问 的页面 置换出去！
    · 具有最好的性能，是页面置换算法的理想状态，但是难以实现，只能用来作为性能评价标准！
    	上述算法中，只有 LRU 的性能与 OPT 性能接近！
   ```

#### 设备管理

##### 磁盘调度算法

1. 先来先服务（FCFS）

   + 优点：公平、简单、每个进程都能依次得到处理，不出现某一个进程的请求长时间得不到满足的情况！
   + 缺点：寻道没有规律，导致耗时较长！

2. 最短寻道时间优先（SSTF）

   对于当前磁道而言，总是选择 需要寻道最短 的进程执行！

   + 优点：最短寻道算法 优化了 寻道的时间，相对于 FCFS 而言，具有较好的寻道性能！
   + 缺点：算法存在 进程的“饥饿”现象：若源源不断的读写请求，与当前磁盘靠近，那么，先前已到的远离当前磁道的请求将被无限期延迟！

3. 扫描算法（SCAN）（电梯算法）

   将 所有进程请求的磁道 排序，寻道时，由最小磁道依次扫描到最大磁道；或者由最大磁道依次扫描到最小磁道。当磁盘机不空闲时，后续的请求将会等待执行，操作系统会对全体等待者进行寻查定序，下次按照优化的次序执行！

   + 优点：不会出现 SSTF 的 “饥饿” 现象！性能上没有 SSTF 优秀！

4. 循环扫描算法（CSCAN）

   移动臂总是从 0 号柱面至 最大号柱面顺序扫描，然后直接返回 0 号柱面重复执行，归途中不再服务，构成循环！

   + 优点：减少了处理新来请求的最大延迟。

   CSCAN 算法规定了磁头单向移动！

#### Linux

+ [常见指令](https://github.com/Snailclimb/JavaGuide/blob/master/docs/operating-system/linux.md)

+ 目录切换

  ```shell
  cd /path
  cd ..# 上一级
  cd / # 根目录
  cd ~ # 用户主目录
  cd - # 上一个操作目录
  ```

+ 目录：增删改查

  ```shell
  mkdir
  ls | ls -l # ls -l 简写为 ll 查看目录下的文件详情（权限等）
  find 目录 参数
  mv # 移修改目录名称 或者 移动文件
  cp -r ... # 拷贝目录 -r 表示递归拷贝
  rm [-rf] # 删除目录 -rf 表示递归强制删除
  ```

+ 文件：增删改查

  ```shell
  touch 文件名 # 创建文件
  ------------------------------
  cat | more | less | tail # 文件查看
  # （cat：文件内容		more：显示百分比		tail -10 查看文件最后 10行）
  tail -f # 能够对文件进行动态监控，例如对 tomcat 日志文件的动态监控，如下：
  tail -f catalina-2020-04-03.log # 对该日志文件进行动态监控，随着程序运行输出 日志
  -------------------------------
  vim 文件 # 修改文件内容，不存在时会创建新文件
  rm [-rf] # 递归强制删除文件
  ```

+ 压缩文件 ：`tar` 命令

  1. 打包压缩

     Linux 中打包后的文件以 `.tar` 结尾；压缩后的文件以 `.gz`结尾；打包并压缩后的文件后缀为：`.tar.gz`

     ```shell
     tar -zcvf 压缩包的文件名 要打包压缩的文件 # 打包压缩某个文件
     -z # gzip 格式压缩
     -c # 打包文件
     -v # 显示运行过程
     -f # 指定文件名
     ```

  2. 解压

     ```shell
     tar [-xvf] 压缩文件 [-C 解压文件位置] # 解压文件到当前目录，或者指定位置
     -x # 代表解压
     ```

+ 权限：chmod 命令

  文件详细信息：

  ![](image\文件属性信息.png)

  + 文件类型

    ```shell
    d # 目录
    - # 文件
    l # 代表软连接
    ```

  + 角色

    属主：/user 	`chmod 中为 u`

    属组：/group	`chmod 中为 g`

    其他用户：other user	`chomd 中为 o`

    `chmod 中使用 a 代表上面三种`

  + 文件权限

    ```shell
    r # 读
    w # 写
    x # 执行
    - # 无任何权限
    ```

  文件权限修改：

  + `=（设置）、+（增） 、-（减）` 符号修改权限

    ```shell
    chmod -R u=rwx,g=rw,o=r /root # 对 root 目录进行权限设定
    -R # 递归设定权限

    chmod -R g-w /root # 修改属组对 root 的权限，去掉写权限！
    ```

  + 权限掩码 设置法

    ```shell
    chmod -R 731 /root # r=1 w=2 x=4
    ```

+ `grep` 命令

  搜索命令：根据字符串搜索

  ```shell
  grep 字符串 要搜索的文件 [--color] # 在指定文件中搜索 指定的字符串，并高亮显示
  --color # 高亮显示
  ```

+ [`ps` 命令](https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html)

  查看进程信息

  ```shell
  ps -ef # 查看所有正在运行的进程（包括端口）
  ps -aux # 查看内存中正在运行的程序信息（包括端口、命令行）

  # 两者都能查看所有进程信息！
  ```

  **常常通过 通道(`|`) 与 `grep` 一起使用，查看某个具体的进程！**

  ```shell
  ps -ef | grep redis # 查看 redis 进程
  # 也可以使用：
  pgrep redis -a
  ```


  ps -ef | grep 6379 # 查看端口为 6379 的进程信息
  # 也可以使用：需要 install 该命令
  lsof -i :6379
  ```

+ **排查问题相关命令**

  ```shell
  grep 内容 文件 # 特定内容：
  top # 查看 CPU 负载，如下：
  $ top -H -p pid

  ls -h 、du -sh # 文件大小：
  df -hl # 磁盘空间大小
  sort # 排序命令 
  	 # 命令可以用于文件内容排序并输出；也可以配合通道，将某些查询命令的执行结果排序后输出
  head # 显示文件前几行/查询结果的前几行（通道）

  # netstat 命令行工具
  netstat -tunlp # 列出正在监听的所有 TCP 或者 UDP 端口，包括使用端口 和 套接字状态的服务
   	# 此命令中使用的选项具有以下含义：
  	-t  # 显示 TCP 端口。
  	-u  # 显示 UDP 端口。
  	-n  # 显示数字地址而不是主机名。
  	-l  # 仅显示侦听端口。
  	-p  # 显示进程的 PID 和名称。仅当您以 root 或 sudo 用户身份运行命令时，才会显示此信息。
  	
  # ss 工具 是 netstat 的新版本
  ss -tunlp

  lsof -i :端口 # 检查某个端口
  ```

  + [磁盘大小、文件大小、排序方法](https://blog.csdn.net/lkforce/article/details/80917306?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3)

+ `kill` 命令

  ```shell
  kill -9 进程号 # 杀死进程
  ```

+ 网络通信指令

  ```shell
  ifconfig # 查看当前系统的网卡信息
  ping # 查看与某台机器的网络连通情况
  netstat -an # 查看当前系统的端口使用情况
  ```

+ `shutdown` 指令

  ```shell
  shutdown -h now # 指定立即关机
  shutdown +5 "System will shutdown after 5 minutes!" # 指定 5 分钟后关机，并提示用户
  ```

+ `rebot`  指令

  ```shell
  rebot -w # 模拟重启（只有记录，并不会真的重启）
  ```

+ 其他指令

  ```shell
  pwd # 当前目录
  sudo 其他指令 # 以管理员身份执行指令
  ```

#### 补充

+ [静态链接、动态连接](https://cyc2018.github.io/CS-Notes/#/notes/计算机操作系统%20-%20链接)

+ 进程组成、线程组成、程序内存布局

+ 中断、硬中断、软中断
+ IO 多路复用：epoll、select、poll