##### IO 读写原理

+ 用户程序进行 IO 读写，依赖于底层的 IO 读写，基本上会用到底层的 `read/write` 两大系统调用。

  在用户程序中，无论是 Socket IO 还是文件 IO，都属于上层应用的开发，它们的 IO 处理流程都是一致的，都依赖于 read/write 系统调用。

+ `read/write`系统调用 *并不是* *物理设备* 和 *内存* 之间数据交互，而是*内存缓冲区之间* 的数据交互；**操作系统会对内核缓冲区进行监控，等待 内核缓冲区的数据达到一定的数量后，会发起系统中断，集中地执行 物理设备的实际 IO 操作。**

+ 内存缓冲区

  + 由于外部设备的直接读写会涉及到 系统中断，系统中断时需要保存进程数据和状态信息，而中断恢复时，需要恢复之前的进程数据和状态信息；同时 CPU 与 外部设备之间的数据访问速度相差较大。

    因此，应用程序 直接访问外部设备将带来一系列的性能问题，于是出现了内存缓冲区。

  + **内存缓冲区 避免了每一次的 IO 操作都发起系统中断；同时可以通过异步操作，平衡操作系统的 CPU执行速度 与 外部设备的访问速度 之间的差异。**

    数据先载入内存缓冲区，将应用程序 与 外部设备之间的交互，转变为 应用程序与内存之间的数据交互。

  + 内存缓冲区分为：内核缓冲区 和 进程缓冲区（用户程序缓冲区）

    - read系统调用：把数据从内核缓冲区复制到进程缓冲区。
    - write系统调用：把数据从进程缓冲区复制到内核缓冲区。

+ Socket IO 、文件 IO

  Socket IO 实际上就是文件描述符对应的文件 IO。

  1. 对应用程序而言：上层应用执行 socket/file 的 read/write 系统调用，实现的是 用户缓冲区 与 内核缓冲区之间的数据传递（中介 IO 操作）。
  2. 对于操作系统而言：操作系统会监视 内核缓冲区，当内核缓冲区空/满，就会进行 内核缓冲区 与 文件/外部设备 之间的数据传递（实际的 IO 操作）。

  ```
  所以：socket 连接，就是创建文件描述符，对应的就是 内核缓冲区<=> 文件 之间实际的 IO 操作。而 上层应用调用 socket.read 就是 用户缓冲区 <=> 内核缓冲区之间的数据传递。

  所以：socket.read() 与 socket 连接是两回事。
  ```

##### read&write

+ 内核缓冲区&进程缓冲区（应用程序）

  <img src="image\io系统调用.jpg" style="zoom:80%;" />

  1. 等待数据准备好
  2. 从内核向进程复制数据 & 从进程向内核写入数据

+ 例如：在 Java 服务端完成一次 socket 请求和响应 流程如下：

  1. 客户端请求：

     Linux 通过网卡读取客户端的请求数据，将数据读取到内核缓冲区

  2. 获取请求数据：

     Java 服务端通过 read 系统调用，从 Linux 内核缓冲区读取数据，再送入 Java 进程缓冲区*（read 数据）*

  3. 服务端业务处理：

     Java 服务端在自己的用户空间中处理客户端的请求。

  4. 服务端返回数据：

     Java 服务器完成数据处理之后，构建好响应数据，将这些数据从 用户缓冲区 写入内核缓冲区。*（write 数据）*

  5. 响应数据给客户端：

     Linux 内核通过 网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。

+ 即：

  ```
  IO设备->内核缓冲区，当 内核缓冲区满，再调用 read，读取数据到 用户程序中

  用户程序 write 到内核缓冲区，当 内核缓冲区满，再将数据写到 外部设备中
  ```

