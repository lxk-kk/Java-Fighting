##### IO 读写原理

+ 用户程序进行 IO 读写，依赖于底层的 IO 读写，基本上会用到底层的 `read/write` 两大系统调用。

+ `read/write`系统调用 *并不是* *物理设备* 和 *内存* 之间数据交互。

  ```
   · read系统调用：把数据从内核缓冲区复制到进程缓冲区。
   · write系统调用：把数据从进程缓冲区复制到内核缓冲区。
   
   · 因此，上层应用中的 IO 操作，实际上并不是物理设备级别的读写，而是缓存的复制。
   	最终是由操作系统内核（kernel）完成 内核缓存区 和 物理设备之间的数据交换。
   	
   · 上层应用 IO：Socket IO、文件 IO
  ```

+ 缓冲区

  ```
   · 由于 外部设备的直接读写会涉及到 系统中断，而系统中断是一个耗时的过程，为了减少底层操作系统的时间损耗，于是有了 内存缓冲区。
   · 内存缓冲区是为了平衡操作系统的内存操作速度 和 外部设备操作速度之间的差异。
  ```

+ 操作系统的操作：

  ```
   · 有了内存缓冲区，就能够将 应用程序与外部设备之间的数据交互，转变为 应用程序与内存之间的交互。
   	
   	底层操作系统会对内核缓冲区进行监控，当缓冲区达到一定的数量时，才会发起系统中断，将缓冲区中的数据传输给外部设备，这避免了频繁的系统中断，提升系统的性能。
  ```

##### read&write

+ 内核缓冲区&进程缓冲区（应用程序）

  <img src="image\io系统调用.jpg" style="zoom:80%;" />

  1. 等待数据准备好
  2. 从内核向进程复制数据 & 从进程向内核写入数据

+ 例如：在 Java 服务端完成一次 socket 请求和响应 流程如下：

  1. 客户端请求：

     Linux 通过网卡读取客户端的请求数据，将数据读取到内核缓冲区

  2. 获取请求数据：

     Java 服务端通过 read 系统调用，从 Linux 内核缓冲区读取数据，再送入 Java 进程缓冲区*（read 数据）*

  3. 服务端业务处理：

     Java 服务端在自己的用户空间中处理客户端的请求。

  4. 服务端返回数据：

     Java 服务器完成数据处理之后，构建好响应数据，将这些数据从 用户缓冲区 写入内核缓冲区。*（write 数据）*

  5. 响应数据给客户端：

     Linux 内核通过 网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。

+ 即：

  ```
  IO设备->内核缓冲区，当 内核缓冲区满，再调用 read，读取数据到 用户程序中
  
  用户程序 write 到内核缓冲区，当 内核缓冲区满，再将数据写到 外部设备中
  ```


##### BIO

+ 在Java应用程序进程中，默认情况下，所有的socket连接的IO操作都是同步阻塞IO（Blocking IO）。

+ 在阻塞式IO模型中，Java应用程序从IO系统调用开始，直到系统调用返回，在这段时间内，Java进程是阻塞的。返回成功后，应用进程开始处理用户空间的缓存区数据。

  ![](image\BIO_1.jpg)

+ 例如：在Java中发起一个socket的read读操作的系统调用，流程大致如下：

  1. 从Java启动IO读的read系统调用开始，用户线程就进入阻塞状态。
  2. 当系统内核收到read系统调用，就开始准备数据。一开始，数据可能还没有到达内核缓冲区（例如，还没有收到一个完整的socket数据包），这个时候内核就要等待。
  3. 内核一直等到完整的数据到达，就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到用户缓冲区中的字节数）。
  4. 直到内核返回后，用户线程才会解除阻塞的状态，重新运行起来。

+ 总之，阻塞IO的特点是：在内核进行IO执行的两个阶段，用户线程都被阻塞了。

+ 阻塞IO的优点是：

  应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起。在阻塞期间，用户线程基本不会占用CPU资源。

+ 阻塞IO的缺点是：

  一般情况下，会为每个连接配备一个独立的线程；反过来说，就是一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。但是，当在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。

##### NIO

+ socket连接默认是阻塞模式，在Linux系统下，可以通过设置将socket变成为非阻塞的模式（Non-Blocking）。使用非阻塞模式的IO读写，叫作同步非阻塞IO（None Blocking IO），简称为NIO模式。在NIO模型中，应用程序一旦开始IO系统调用，会出现以下两种情况：

  1. 在内核缓冲区中没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。
  2. 在内核缓冲区中有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。

  ![](image\NIO_1.jpg)

+ 例如：发起一个非阻塞socket的read读操作的系统调用，流程如下：

  1. 在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回。所以，为了读取到最终的数据，用户线程需要不断地发起IO系统调用。
  2. 内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据，它会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到的用户缓冲区的字节数）。
  3. 用户线程读到数据后，才会解除阻塞状态，重新运行起来。

+ 也就是说，用户进程需要经过多次的尝试，才能保证最终真正读到数据，而后继续执行。

+ 同步非阻塞IO的特点：

  应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续轮询，直到完成IO系统调用为止。

+ 同步非阻塞IO的优点：

  每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。

+ 同步非阻塞IO的缺点：

  不断地轮询内核，这将占用大量的CPU时间，效率低下。

+ 说明

  ```
  同步非阻塞IO，可以简称为NIO，但是，它不是Java中的NIO，虽然它们的英文缩写一样，希望大家不要混淆。
  Java的NIO（NewIO），对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）
  ```

##### IO 多路复用

+ 如何避免 同步非阻塞IO 模型中轮询等待的问题呢？

  这就是 IO 多路复用模型！

+ IO 多路复用模型，引入了一种新的系统调用：查询 IO 的就绪状态！

  在 Linux系统中，对应的系统调用为 select/epoll 系统调用。

  通过系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后应用程序根据就绪的状态，进行相应的 IO 系统调用。

+ 目前支持的 IO 多路复用的系统调用有 select、poll、epoll 等

  select 系统调用几乎在所有操作系统系统上都支持，具有良好的跨平台特性。

  poll 是 select 的改进版

  epoll 是 poll 系统调用的 Linux 增强版本。

+ 在 IO 多路复用模型中，通过 select / epoll 系统调用，单个应用程序的线程可以不断地轮询成百上千的 socket，当某个或者某些 seocket 网络连接有 IO 就绪状态时，就返回对应的可以执行的读写操作。

+ 例如：IO 多路复用模型的 read 操作：

  ![](image\IO 多路复用_1.jpg)

  1. 选择器注册

     在这种模式下，首先将需要 read 操作的目标 socket 网络连接，提前注册到 select/epoll 选择器中。

     Java 中对应的选择器类就是 Selector 类，然后才可以开启整个 IO 多路复用模型的轮询程序。

  2. 就绪状态的轮询

     通过选择器的查询方法，查询注册过的所有 socket 连接的就绪状态。通过查询的系统调用，内核就会返回一个就绪的 socket 列表。当任何一个注册过的 socket 中的数据准备好了，内核缓冲区有数据（就绪）了，内核就会将该 socket 加入到就绪的列表中。

     当用户进程调用了 select 查询方法，那么整个线程会被阻塞。

  3. 用户线程获得了 就绪状态的列表后，根据其中的 socket 连接，发起 read 系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区中。

  4. 复制完成之后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。

+ IO 多路复用模型特点：

  + IO 多路复用模型的 IO 涉及了两种 系统调用。

    1. select/epoll 就绪查询
    2. IO 操作

  + IO 多路复用莫i选哪个建立在操作系统的基础设施之上，即操作系统的内核必须能够提供多路分离的系统调用 select/epoll。

  + 和 NIO 模型相似，多路复用 IO 也需要轮询。

    负责 select/epoll 状态查询调用的线程，需要不断地进行 select/epoll 轮询，查找出达到 IO 操作就绪的 socket 连接。

  + IO 多路复用模型 与 同步非阻塞IO模型 也有密切关系：

    对于注册在选择器上的每一个可以查询的socket连接，一般都设置成 同步非阻塞模型。（对于用户程序而言是无感知的）

+ IO 多路复用模型的优点：

  与 一个线程维护一个 连接的阻塞 IO 模式相比，使用 select/epoll 的最大优势在于，一个选择器查询线程可以同时处理成千上万个连接。系统不必创建大量的线程，也不必维护这些线程，大大减少了系统的开销。

+ IO 多路复用模型的缺点：

  本质上 select/epoll 系统调用是阻塞式的，属于 同步IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。

  用于彻底解除的线程阻塞，就必须使用 异步IO模型。

##### AIO

+ AIO：异步 IO 模型

+ AIO 的基本流程：

  用户线程通过 系统调用，向内核注册某个 IO 操作。内核在整个 IO 操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。

+ 在异步 IO 模型中，在整个内核的数据处理过程中，包括内核将数据从网络物理设备（网卡）读取到内核缓冲区、将内核缓冲区中的数据复制到用户缓冲区中，用户程序都不需要阻塞。

  ![](image\AIO_1.jpg)

+ 例如：一个 异步 IO 的 read 操作的系统调用过程：

  1. 当用户线程发起了 read 系统调用，立刻就可以开始去做其他的事，用户线程不阻塞。

  2. 内核就开始了 IO 的第一个阶段：准备数据。

     等到数据准备好了，内核就会将数据从内核缓冲区复制到用户缓冲区（用户空间）。

  3. 内核会给用户发送一个 信号（signal），或者回调用户线程注册的回调接口，告诉用户线程 read 操作完成了。

  4. 用户线程读取用户缓冲区的数据，完成后续的业务操作。

+ AIO 的特点：

  在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的。用户线程需要接收内核的 IO 操作完成的事件，或者用户线程需要注册一个 IO 操作完成的回调函数。

  正是因为如此，异步IO 有时也称为 信号驱动 IO

+ 异步 IO 异步模型的缺点：

  应用程序仅需要进行事件的注册与接收，其余的工作都留在了操作系统，也就是说需要底层内核提供支持。

  理论上，异步 IO 是真正的 异步输入输出，它的吞吐量傲宇 IO 多路复用模型的吞吐量。

+ 总结：

  就目前而言，Windows 系统下通过 IOCP 实现了真正的 异步IO。

  而在 Linux 系统下，异步 IO 模型在 2.6 版本才引入，目前并不完善，其底层实现仍然使用 epoll，与 IO 多路复用相同，因此在性能上没有明显的优势。

  大多数高并发服务端的程序，一般都是基于 Linux 系统的，并且，这类高并发网络应用程序的开发，大多都是采用  IO 多路复用模型。（Netty 就是 IO 多路复用模型，而不是 异步IO模型）

  

