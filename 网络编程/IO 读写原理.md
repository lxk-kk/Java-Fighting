##### IO 读写原理

+ 用户程序进行 IO 读写，依赖于底层的 IO 读写，基本上会用到底层的 `read/write` 两大系统调用。

+ `read/write`系统调用 *并不是* *物理设备* 和 *内存* 之间数据交互。

  ```
   · read系统调用：把数据从内核缓冲区复制到进程缓冲区。
   · write系统调用：把数据从进程缓冲区复制到内核缓冲区。
   
   · 因此，上层应用中的 IO 操作，实际上并不是物理设备级别的读写，而是缓存的复制。
   	最终是由操作系统内核（kernel）完成 内核缓存区 和 物理设备之间的数据交换。
   	
   · 上层应用 IO：Socket IO、文件 IO
  ```

+ 缓冲区

  ```
   · 由于 外部设备的直接读写会涉及到 系统中断，而系统中断是一个耗时的过程，为了减少底层操作系统的时间损耗，于是有了 内存缓冲区。
   · 内存缓冲区是为了平衡操作系统的内存操作速度 和 外部设备操作速度之间的差异。
  ```

+ 操作系统的操作：

  ```
   · 有了内存缓冲区，就能够将 应用程序与外部设备之间的数据交互，转变为 应用程序与内存之间的交互。
   	
   	底层操作系统会对内核缓冲区进行监控，当缓冲区达到一定的数量时，才会发起系统中断，将缓冲区中的数据传输给外部设备，这避免了频繁的系统中断，提升系统的性能。
  ```

##### read&write

+ 内核缓冲区&进程缓冲区（应用程序）

  <img src="image\io系统调用.jpg" style="zoom:80%;" />

  1. 等待数据准备好
  2. 从内核向进程复制数据 & 从进程向内核写入数据

+ 例如：在 Java 服务端完成一次 socket 请求和响应 流程如下：

  1. 客户端请求：

     Linux 通过网卡读取客户端的请求数据，将数据读取到内核缓冲区

  2. 获取请求数据：

     Java 服务端通过 read 系统调用，从 Linux 内核缓冲区读取数据，再送入 Java 进程缓冲区*（read 数据）*

  3. 服务端业务处理：

     Java 服务端在自己的用户空间中处理客户端的请求。

  4. 服务端返回数据：

     Java 服务器完成数据处理之后，构建好响应数据，将这些数据从 用户缓冲区 写入内核缓冲区。*（write 数据）*

  5. 响应数据给客户端：

     Linux 内核通过 网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议，会将数据发送给目标客户端。

+ 即：

  ```
  IO设备->内核缓冲区，当 内核缓冲区满，再调用 read，读取数据到 用户程序中
  
  用户程序 write 到内核缓冲区，当 内核缓冲区满，再将数据写到 外部设备中
  ```

  







