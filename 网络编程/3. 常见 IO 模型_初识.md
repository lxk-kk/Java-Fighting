##### 阻塞/非阻塞 vs 同步/异步

###### 1. 广义上

- 阻塞 和 非阻塞 是相对于调用者而言的。
  - 阻塞：调用者等待 调用的逻辑处理完成 与 结果返回。
  - 非阻塞：调用者不必等待调用的逻辑处理完成，可以先执行其他的操作，一段时间之后，再来查看操作是否完成。（查询的方式）


- 同步 和 异步 是相对于 被调用者 而言的。
  - 同步：被调用者会将操作执行完成，再返回结果。
  - 异步：无论当前操作是否执行完成，都会返回，表示被调用者已经被触发，当操作真正执行完成之后，被调用者会通过 信号/回调 机制通知调用者。（通知的方式）

###### 2. IO 模型中

- 阻塞 和 非阻塞

  - 阻塞：

    - IO 模型的第一个阶段

      - read：如果内核缓冲区中没有数据，则用户线程阻塞，直到内核缓冲区中有数据。
      - write：如果内核缓冲区满了，则用户线程阻塞，直到内核缓冲区有空闲区域。

    - IO 模型的第二个阶段：

      用户线程阻塞，直到完成 用户缓冲区 于 内核缓冲区之间的数据拷贝

      - read：内核缓冲区 -> 用户缓冲区
      - write：用户缓冲区 -> 内核缓冲区

  - 非阻塞

    - IO 模型的第一个阶段

      执行 read/write 系统调用时，如果 内核缓冲区空 / 内核缓冲区满，则直接返回 错误，此时，用户线程可以执行其他操作。

      过一段时间，查询 内核缓冲区 是否有数据/是否有空闲区域

    - IO 模型的第二个阶段

      对于 AIO 而言，用户线程不必等待 用户缓冲区于内核缓冲区 之间的数据拷贝，而是可以执行其他操作。

- 同步 和 异步

  - 同步：

    - IO 模型的第一个阶段：

      如果内核缓冲区中存在数据，则直接执行第二个阶段！

      如果内核缓冲区中没有数据，则直接返回错误。

    - IO 模型的第二个阶段：

      操作系统完成 内核缓冲区 与 用户缓冲区 之间的数据拷贝后，再返回

  - 异步：

    IO 模型作为一个整体操作，一旦调用 read/write 就会触发 IO 操作，此时操作系统直接返回，表示  IO 操作已触发。

    真正的 IO 操作将会由操作系统完成，当整个 IO（第一阶段+第二阶段） 完成之后，就会以 信号/回调 机制通知用户程序

##### BIO

- 在Java应用程序进程中，默认情况下，所有的socket连接的IO操作都是同步阻塞IO（Blocking IO）。

- 在阻塞式IO模型中，Java应用程序从IO系统调用开始，直到系统调用返回，在这段时间内，Java进程是阻塞的。返回成功后，应用进程开始处理用户空间的缓存区数据。

  ![](image\BIO_1.jpg)

- 示例

  ```java
  // 如果内核中没有数据，则阻塞用户线程，直到内核中有数据，并当数据拷贝到用户线程后，用户线程唤醒。
  Object data = socket.read();
  ```

- 例如：在Java中发起一个socket的read读操作的系统调用，流程大致如下：

  1. 从Java启动IO读的read系统调用开始，用户线程就进入阻塞状态。
  2. 当系统内核收到read系统调用，就开始准备数据。一开始，数据可能还没有到达内核缓冲区（例如，还没有收到一个完整的socket数据包），这个时候内核就要等待。
  3. 内核一直等到完整的数据到达，就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到用户缓冲区中的字节数）。
  4. 直到内核返回后，用户线程才会解除阻塞的状态，重新运行起来。

- 总之，**阻塞IO的特点是：在内核进行IO执行的两个阶段，用户线程都被阻塞了。**

  ```
  调用 read 之后，用户线程被阻塞，直到 用户缓冲区 中有数据！
  从 read 开始调用，到 用户缓冲区中有数据，之间，是两个 IO 阶段！
  1， 查询内核缓冲区是否有数据
  2， 将数据从内核缓冲区复制到用户缓冲区。

  这两个阶段对于 阻塞IO 而言，都是阻塞的！
  ```

- 阻塞IO的优点是：

  应用的程序开发非常简单；在阻塞等待数据期间，用户线程挂起。在阻塞期间，用户线程基本不会占用CPU资源。

- 阻塞IO的缺点是：

  **一个连接一个工作线程**；即，一个线程维护一个连接的IO操作。

  在并发量小的情况下，没什么问题。

  *但在高并发的应用场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上阻塞IO模型在高并发应用场景下是不可用的。*

##### NIO

- NIO**（None-Blocking IO）**

  *四种 IO 基础模型之一，非阻塞式 IO！！！*

- socket连接默认是阻塞模式，在Linux系统下，可以通过设置将socket变成为非阻塞的模式（Non-Blocking IO）。

  在 NIO 模型中，应用程序一旦开始 IO 系统调用，会出现以下两种情况：

  1. 内核缓冲区*没有数据可读*，返回错误！

     ```
     如果要读取到数据，用户线程 就必须轮询 是否有数据可读！
     ```

  2. 内核缓冲区*有数据可读*，当前线程阻塞，直到数据从内核缓冲复制到用户进程缓冲区。拷贝结束，则线程苏醒，继续执行后续操作。

  ![](image\NIO_1.jpg)

- 示例

  ```java
  while(true){
    
    // 没有数据则返回 error
    data = socket.read();
    
    // 如果得到数据，则处理数据，并跳出循环
    if(data != error){
      // 处理数据
      break;
    }
    // 否则：轮询 socket.read() 调用
  }
  ```

- **同步非阻塞 vs 同步阻塞**

  + 阻塞

    ```
     如果内核缓冲区存在数据，用户线程等待数据从内核缓冲区拷贝到用户缓冲区。
     如果内核缓冲区中没有数据，那么，read 调用从内核缓冲区中读取不到数据，用户线程将会被阻塞，直到内核缓冲区有数据时，并且数据拷贝到 用户缓冲区后，用户线程唤醒，重新持有 CPU 资源。
    ```

    + 优点

      实现方式简单，有数据则直接返回，没有就阻塞用户线程，释放 CPU 资源，直到内核有数据。

    + 缺点

      如果内核没有数据，那么用户线程将会被阻塞，做不了其他事。

  + 非阻塞

    ```
     如果内核缓冲区中存在数据，用户线程等待数据从内核缓冲区拷贝到用户缓冲区。
     如果内核缓冲区中没有数据，则 read 调用直接返回 error，用户线程不再被阻塞。如果用户想要获取到数据，则必须轮询 read 调用，直到内核缓冲区中存在数据。
    ```

    + 优点

      如果内核没有数据，则直接返回，不阻塞用户线程，用户线程可以执行其他的操作。等到一定需要数据的时候，再轮询内核是否存在数据。

    + 缺点

      轮询会占用 CPU 资源，如果轮询的次数过多，会导致 CPU 占用率过高，影响性能。因此，最好不要使用 while 的方式读取数据。

- 例如：发起一个非阻塞 socket 的 read 系统调用：

  1. 在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回。所以，为了读取到最终的数据，用户线程需要不断地发起IO系统调用。
  2. 内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据，它会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到的用户缓冲区的字节数）。
  3. 用户线程读到数据后，才会解除阻塞状态，重新运行起来。

- 也就是说，用户进程需要经过多次的尝试，才能保证最终真正读到数据，而后继续执行。

##### IO 多路复用

- **Java NIO** *（New IO）多路复用 IO*

  *不是四种基础 IO 模型中的NIO（None Blocking IO）模型，而是另外的一种模型：IO多路复用模型（IO Multiplexing）*

+ **IO 多路复用模型**

  - IO 多路复用模型的 IO 涉及了两种 系统调用。

    1. select/poll/epoll 就绪查询

       ```
       select 系统调用几乎在所有操作系统系统上都支持，具有良好的跨平台特性。

       poll 是 select 的改进版

       epoll 是 poll 系统调用的 Linux 增强版本。
       ```

    2. read/write 系统调用

  - IO 多路复用模型建立在操作系统的基础设施之上，即操作系统的内核必须支持系统调用 select/epoll。

+ **Java NIO**

  ![](image\IO 多路复用_1.jpg)

  + 将所有 socket 连接封装成 socket channel 注册到 selector 中。

  + select 线程遍历 socket channel 列表，查询是否有 socket 读写事件到达（如果没有则阻塞 select 线程*【用户线程 — boss 线程】*）

    ```
    因此，多路复用 IO，只使用一个 select 线程管理所有 socket 连接，并监听 socket 上的读写事件。

    --【第一阶段】等待内核缓冲区可读写！！！
    ```

  + 如果 socket 有可读写事件，则创建一个线程，处理该 socket 读写事件（内核缓冲区 与 用户缓冲区之间数据拷贝，会阻塞线程*【用户线程 — worker 线程】*）

    ```
    因此，多路复用 IO，一个线程处理一个 socket 请求

    --【第二阶段】实现 内核缓冲区 与 用户缓冲区 之间的数据拷贝！！！
    ```

+ 例如：socket  read 示例：

  1. 选择器注册

     在这种模式下，首先将需要 read 操作的目标 socket 网络连接，提前注册到 select/epoll 选择器中。

     Java 中对应的选择器类就是 Selector 类，然后才可以开启整个 IO 多路复用模型的轮询程序。

  2. 就绪状态的轮询

     通过选择器的查询方法，查询注册过的所有 socket 连接的就绪状态。通过查询的系统调用，内核就会返回一个就绪的 socket 列表。当任何一个注册过的 socket 中的数据准备好了，内核缓冲区有数据（就绪）了，内核就会将该 socket 加入到就绪的列表中。

     当用户进程调用了 select 查询方法，那么整个线程会被阻塞。

  3. 用户线程获得了 就绪状态的列表后，根据其中的 socket 连接，发起 read 系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区中。

  4. 复制完成之后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。

+ **Java NIO 阶段分析**

  + 第一阶段：查询 socket 连接上的读写事件 — boss 线程

    IO 多路复用模型，引入了新的**系统调用（select、poll、epoll）**查询 socket 连接上的 IO 就绪状态。意味着**内核自动轮询所有 socket 连接，而非应用程序。**

    ```
    内核自动轮询：使得 Java NIO(IO 多路复用) 比 NIO模型 效率更高。

    NIO 模型：用户程序轮询 -> 内核查询
    Java NIO：内核轮询
    ```

    通过系统调用，一个线程可以监视多个 socket 文件描述符，一旦某个描述符就绪（内核缓冲区可读/可写），内核就将该 socket 事件返回给应用程序。

    没有 socket 读写事件到达时，boss 线程阻塞！

  + 第二阶段：用户缓冲区、内核缓冲区之间的数据拷贝— worker 线程

    worker 线程：实现业务逻辑，执行 read/write 系统调用。

    read/write 系统调用时，worker 线程阻塞。


- **代替 Java NIO**

  - 可以通过 多线程（线程池）+ 阻塞 IO 实现 Java NIO 的作用！

    ```
    多线程：每个线程对应一个连接
    阻塞 IO：每个线程都需要阻塞等待当前连接有 读写事件 到达，然后阻塞拷贝缓冲区数据。
    ```

  - **Java NIO 一个线程管理所有 socket 连接，一个线程一个读写请求**

    > - 相对于 多线程+阻塞 IO 的方式，Java NIO 并不需要为 空闲 连接建立处理线程，只有 socket 连接中有读写事件到达时，才会启用线程执行 IO 系统调用。
    >
    >   每个连接对应一个处理线程，会造成很大的资源占用，尤其对于长连接而言，线程资源一直不被释放，如果后续连接数增多，就会造成性能上的瓶颈。
    >
    > - 因此，Java NIO 主要减少了空闲连接带来的 线程资源消耗
    >
    > - 因此，Java NIO 使用于 空闲连接数较多的场景。

- Java NIO 实现

  Java NIO 基于 Reactor 模式实现，有 3种 线程模型的实现方式：

  1. Reactor 单线程模型

     一个线程负责全部的工作：轮询就绪 socket 描述符 + 执行 业务逻辑 + read/write 系统调用

     ```
     不适用于高负载、大并发的应用场景：
     1. 当 NIO 线程负载过重，处理速度将变慢，会导致大量的 socket 连接超时，而触发的超时重发又会增加 NIO 的负载，恶性循环。最终导致大量的消息积压和处理超时，NIO 线程成为系统的性能瓶颈。

     2. 可靠性问题：一旦 NIO 线程出现异常，或者进入死循环，将导致整个系统通信模块不可用，造成节点故障。
     ```

  2. Reactor 多线程模型

     boss 线程：负责监听服务端连接请求，轮询 socket 就绪状态

     worker 线程池：负责消息的读取 编码、解码 和 发送，并执行 socket 读写事件及相关的业务逻辑

     ```
     大多数场景下，能够满足需求，再特殊场景中，一个 NIO 线程负责处理所有的 客户端连接 可能出现性能问题。
     例如：百万客户端并发连接，或者服务端对客户端的握手消息进行安全认证，认证本身损耗性能。
     ```

     *上述 Java NIO 都是讲的这种模型*

  3. Reactor 主从线程池模型

     单线程：监听连接事件

     boss 线程池：轮询已注册的 socket 连接上的 读写事件

     worker 线程池：执行实际的 IO 逻辑及 read/write 系统调用

     ```
     解决了上述的问题
     ```

##### AIO

- AIO：异步 IO 模型

  异步 IO 模型需要底层操作系统的支持，在 Java 7 中，提供了 Asynchronous IO

- AIO 的基本流程：

  用户线程通过 系统调用，向内核注册某个 IO 操作。内核在整个 IO 操作（包括数据准备、数据复制）完成后，通知用户程序，用户执行后续的业务操作。

- 在异步 IO 模型中，在整个内核的数据处理过程中，包括内核将数据从网络物理设备（网卡）读取到内核缓冲区、将内核缓冲区中的数据复制到用户缓冲区中，用户程序都不需要阻塞。

  ![](image\AIO_1.jpg)

- 例如：一个 异步 IO 的 read 操作的系统调用过程：

  1. 当用户线程发起了 read 系统调用，立刻就可以开始去做其他的事，用户线程不阻塞。
  2. 内核就开始了 IO 的第一个阶段：准备数据。等到数据准备好了，就开始第二个阶段：内核就会将数据从内核缓冲区复制到用户缓冲区（用户空间）。
  3. 内核会给用户发送一个 信号（signal），或者回调用户线程注册的回调接口，告诉用户线程 read 操作完成了。
  4. 用户线程读取用户缓冲区的数据，完成后续的业务操作。

- AIO 的特点：

  在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的。用户线程需要接收内核的 IO 操作完成的事件，或者用户线程需要注册一个 IO 操作完成的回调函数。

- 异步 IO 模型的缺点：

  应用程序仅需要进行事件的注册与接收，其余的工作都留在了操作系统，也就是说需要底层内核提供支持。

  理论上，异步 IO 是真正的 异步输入输出，它的吞吐量高于 IO 多路复用模型的吞吐量。

- 总结：

  就目前而言，Windows 系统下通过 IOCP 实现了真正的 异步IO。

  而在 Linux 系统下，异步 IO 模型在 2.6 版本才引入，目前并不完善，其底层实现仍然使用 epoll，与 IO 多路复用相同，因此在性能上没有明显的优势。

  大多数高并发服务端的程序，一般都是基于 Linux 系统的，并且，这类高并发网络应用程序的开发，大多都是采用  IO 多路复用模型。（Netty 就是 IO 多路复用模型，而不是 异步IO模型）



##### 一直没搞懂：

- [详见 IO 模型](https://blog.csdn.net/ocean_fan/article/details/79622956) ｜ [网络 IO 模型](https://blog.csdn.net/zhoudaxia/article/details/8974779?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-)