#### 数据库_B+ 树 算法篇

##### 介绍

+ B+ 树由 平衡二叉树 演变而来！它是一棵 多叉 平衡树（Balanced Tree）

  二叉搜素树 -> 二叉平衡树 -> m 叉树 -> B 树 -> B+树

##### 二分查找

+ 二分查找法（binary search）也称为折半查找法

  在一组有序数组中，通过在查询范围，对比中间值，逐渐将查询范围缩小，直到查询到结果 或者 范围缩小到0 时 结束！

+ 时间复杂度

  O(logN)

##### 二叉查找树

+ 二叉查找树：左节点的键值 总是 小于根节点的键值，右节点的键值总是大于根节点的键值！

  <img src="image_Tree\二叉搜索树.png" style="zoom:50%;" />

+ 对二叉树搜索进行 中序遍历，便能得出 有序结果！

  如上：中序遍历结果为：2、3、5、6、7、8

+ 缺点：

  当二叉查找树中 根节点值 最小时，会退化成单链表：查询的时间复杂度从 O(logN) 退化成 O(N)！

  此时的二叉查找树，便没有了高效的性能！

##### 平衡二叉树 AVL

+ 平衡二叉树

  先满足二叉查找树的特点，并且，对于任意结点 必须满足其 两个子树高度差不超过 1。

+ 维护

  AVL 是严格的自平衡，严格要求左右子树的高度差不超过1，如果对 AVL 树执行增、删、改 这三个操作后，不满足定义，需要1次或者多次调整，使其满足定义！

+ 调整旋转

  1. R 旋转
  2. L 旋转
  3. RL 旋转
  4. LR 旋转

##### m 叉树

+ 平衡二叉树的查找效率已经比较如意了，但是，如果数据量大了，树的高度也会增加！

  + 例如：有 10^6 个索引时，使用二叉树，树的高度至少是 20！
    $$
    log_2 10^6 \approx 20
    $$
    由公式可见，若想要降低树的高度，就需要将 低数 变大：将树的出度 增加 —— 多叉树！

+ m 叉树 定义

  1. 每个结点 有m个子结点（m-1 个键值）
  2. 每个 结点中的键值按照升序排列！
  3. 前 i 个子结点中的键值都小于 第 i 个键值！
  4. 后 m-i 个子结点中的键值都大于第 i 个键值！

+ 典型的 m 叉树有 2-3-4 Tree 以及 B-Tree！

##### B 树

+ 介绍

  B 树（B-Tree）是一种树状结构，能够存储数据，对数据进行排序并允许以 O(logN) 的时间复杂度进行 查找、顺序读取、插入 和 删除的数据结构。

  B 树 是一棵 m 叉树，它与自平衡的二叉查找树不同，B 树为系统最优化 大量数据的 读写操作！

  B 树 算法减少定位记录时所经历的中间过程，从而加快存取熟读，普遍应用在数据库和文件系统中！

+ 应用

  将大型数据库文件存储在硬盘上时，便采用 B 树，以减少硬盘访问次数！

+ B 树定义：

  0. **首先是棵 m叉树**！

  1. 树中的**每个结点至多有 m 个子结点（m 指的是树的阶数）**

     即：树中的每个结点至多有 m-1 个关键字！

  2. 若 **根结点 不是叶子结点，则至少有两棵子树**！

     即：当根结点为叶子结点时，可以没有子树；不为叶子结点时，至少有一个关键字，也就是说出度至少为 2 ！

  3. **除根结点之外，所有非叶子结点至少有`m/2（向上取整）`个叶子结点**！

  4. 所有的非叶子结点中必须包含如下属性：

     关键字总数 n、关键字、指向子结点的指针（有 n 个关键字，就必须有 n+1 个指针）

  5. **所有的叶子结点都出现在同一层上，叶子结点中不包含关键字，它是个空 结点**！！

     即：所有的叶子结点具有相同的深度 = 树高！
  
  ![](image_Tree\B树.webp)
  
+ 维护 B树 定义：

  在对 B 树 进行增删时，需要保证 修改的树 依旧满足B 数据的定义！

  1. 插入时：检查结点中的关键字是否 大于 m-1 ，如果大于，则选出结点的中间关键字 作为父节点的新关键字，将本结点分裂成两个结点！此时，父结点中关键字增加，相当于又做了一次增加操作，此时，依旧按照此方法执行。这是个向上分裂的过程！
  2. 删除时：检查结点中的关键字是否 小于 `m/2(向上取整)`，如果小于则：
     1. 如果兄弟结点中的关键字够多，就拖下父节点关键字，并朝兄弟结点中借一个升级为父节点的关键字！
     2. 如果兄弟结点中的关键子不够，就拖下父节点关键字，一起和兄弟结点合并！此时父结点中关键字减少，相当于又做了一次删除操作，此时，依旧按照上述方法执行。这是个向上合并的过程！

##### B+ 树

###### 定义

+ B+ 树是从 B 树衍生而来的，做了两点改进：

  1. **非叶子结点 仅仅具有索引作用，所有数据存放在叶子节点中！**

     B 树 与 B+ 树的查询时间复杂度虽然差不多，但是，*B 树只要匹配到关键字就能返回，而 B+ 树必须查询到叶子结点，并将叶子结点中的数据放到内存中，才能查询到具体的记录*！

  2. 树的**所有叶子结点构成一个有序链表**，可以**按照关键字排序的次序遍历全部记录（范围查询）**

     这样能支持 InnoDB 进行范围查询，通过叶子结点之间的指针，能够方便的顺序遍历，而不需要像 B树 一样对每一层遍历！

###### 提问

+ *InnoDB 为什么不使用 二叉查找树 作为存储结构* ？ 

  1. 二叉查找树会退化成 单链表，查找的时间是 O(N)，性能极具下降！

  2. 尽管使用了自平衡的二叉树，当数据量较大时，树的高度也会增加

     例如：有 10^6 个索引时，使用二叉树，树的高度至少是 20！

     要想性能更优，可以增加树的出度，变成多叉树！

+ *InnoDB 为什么不使用 RB-Tree 作为存储结构* ？

  1. 虽然 RB-Tree 是自平衡的，但是，它依旧是二叉树，大量数据下，树的高度会比 B+ 树高很多！

  2. 使用 B+ 树能够充分利用 **磁盘预读的特性**！

     ```
     为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。
     
     操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。（空间局部性？）
     ```

+ *InnoDB 为什么不使用 多叉树 作为 存储结构* ？

  1. 多叉树虽然能降低树的高度，但是，多叉树的数据遍布在 叶子结点和非叶子结点之间，也就是说，结点既是数据也是索引！

     对于大量数据的情况下，无疑，这棵树是不能存放在内存中的，而是要存放到磁盘！

     那么，每次对比索引搜需要先进行磁盘IO 取出索引，再对比，然后再从磁盘中获取下一个索引！

     这就涉及到大量的磁盘IO —— 性能极具下降！

##### 红黑树

###### 介绍

+ RB-Tree 是一棵 自平衡的二叉查找树，时间复杂度 和 AVL 树相同！

+ 区别在于

  + RB-Tree 是非严格的平衡，而 AVL 树是严格的自平衡！

    RB-Tree 失衡后，最多只需要 3 次旋转达到部分平衡，而 AVL 树会一直旋转，直到树中的结点满足 左右子树高度差不超过 1。

    即：红黑树 使用非严格的平衡 换取增删的旋转次数！

  + RB-Tree 恢复平衡更快；AVL 树高度平衡，查找效率相对较高！

    在读多写少的场景下，可以使用过AVL 树，否则选择 RB-Tree

    [AVL 树 vs RB-Tree](https://www.jianshu.com/p/37436ed14cc6)

+ 定义

  1. RB-Tree 结点是 红色 或者 黑色

  2. 根节点是黑色

  3. 红色结点的两个子结点必须是黑色！

     即：从叶子结点到跟结点 的所有路径上，不能出现连续的两个 红节点！

  4. 每个叶子结点都是 黑色 的空结点（null 结点）

  5. 从 任一结点 到 某个叶子结点 的 所有路径之间都包含相同数目的黑色结点！

     ![](image_Tree\红黑树.jpg)

+ 维护 RB-Tree 定义

  当执行 增、删 操作时，可能打破 RB-Tree 的定义，因此，需要通过 变色 和 旋转使其达到定义标准！

  + 变色

    将红色结点变成黑色结点 或者 将黑节点变成红色结点，使其满足定义！

  + 旋转

    如果变色已经不能满足要求，那么视情况左旋或者右旋！

  [红黑树详解](https://mp.weixin.qq.com/s/WnYC0ESnLmtcoWE4FTpxHw)

+ 应用

  TreeMap、HashMap（Jdk1.8）、ConcurrentHashMap（Jdk1.8）

