##### InnoDB B+ 树

```java
/*
InnoDB 底层储存结构为 B+树，B+树的每个结点对应 innodb 的一 页(page) ，page的大小固定，一般设为 16k 。其中非叶子节点只有键值，叶子结点包含完整数据，叶子结点的页与页之间构成链表，方便范围查询！
使用场景：
 1、经常更新的表，适合处理多重并发的更新请求
 2、支持事务
 3、可以从灾难中恢复 (使用 bin-log 日志等可以恢复)
 4、仅 innodb 支持外键约束
 5、支持 自增列属性（只有主键为数值类型时可自增）
*/
```

##### InnoDB存储引擎 与 MyISAM存储引擎

```java
/*
1、mysql 5.5以后默认的存储引擎是 innodb，之前是 MyISAM
2、innodb 支持事务，myisam 不支持事务
3、innodb 支持外键，myisam 不支持外键
4、innodb 支持行级锁和表级锁，myisam 只有表锁
5、innodb 不支持 全文索引FullTEXT，myisam支持全文索引
6、innodb 支持聚集索引，索引和数据存放再一个文件中，myisam 是非聚集索引，索引和数据在不同的文件中
7、innodb 必须存在主键，如果用户不设置，则会自动生成一个用户不可见的主键，myisam可以没有任何索引和主键，它的索引用于保存 数据的 行地址！
8、对于获取表的行数 select count() from table; innodb 会遍历整个表进行计算，消耗大，myisam 维护了一个保存行数的值，可以直接取出！
*/
```

##### 储存过程 及其 优缺点

```java
/*
储存过程
	是封装了 特定功能的 SQL 语句集 的代码块，存储在数据库中，是预编译代码块，第一次调用编译后，再次调用不再需要编译！
	
例如：
    // 创建 名为 GetUserAccount 的储存过程
    create Procedure GetUserAccount
    as
    select * from  UserAccount
    go

    // 执行上述存储过程
    exec GetUserAccount

优点：
1、将 sql 代码封装，并保存在数据库中
2、支持 sql 调用，也支持 高级编程语言调用 java 中提供了 API
3、存储过程 是一个预编译代码块，执行效率高
4、一个存储过程 代替 大量的 T_SQL 语句，可以降低网络通信量，提高通信速率
缺点：
1、每个数据库的 存储过程 语法都不一样，可以移植性差！
2、业务逻辑放在数据库上，难以迭代！
*/
```

##### 数据库 3 大范式

```java
/*
范式是具有最小冗余的表结构！

第一范式：
	每一列字段都是不可再分的最小数据单元：确保每列的原子性！
        例如：
            Address=中国南京 	
        则可再分：
            Country=中国	City=南京

第二范式：
	在第一范式的基础上，表中的非主键列不存在对主键的部分依赖：第二范式要求每个表只描述一件事！
        例如：
            Order表	字段：订单编号、产品编号、订购日期、价格
        则可分为两个表：Order表、Product表
            Order表		字段：订单编号、订购日期
            Product表	字段：产品编号、价格

第三范式：
	在第二范式的基础上，表中的列不存在对非主键列的传递依赖！
		例如：
			Order表	字段：订单编号、订购日期、顾客编号、顾客姓名
		则可便为第三范式表：
			（去掉字段`顾客姓名`，因为 `顾客姓名` 依赖于非主键列 `顾客编号` ）
			Order表 	字段：订单编号、订购日期、顾客编号
*/
```

##### 事务

```java
/*
事务(transaction)
	事务是作为 单个逻辑工作单元 执行的 一系列操作，这些操作 作为一个整体 一起向系统提交，并保证 要么都执行、要么都不执行。 事务是一个 不可分割的 工作工作单元！

事务 4 大特性：ACID
【 原子性 Atomic 】事务中的所有操作，作为一个整体，要么一起提交，要么都不提交
【 一致性 Consistency 】事务完成时，数据必须处于一致状态！
	例如：银行转账 A账户 -> B账户
		A账户 ：转出 1000	B账户：必须收到 1000 才能算数据保持一致
【 隔离性 Isolation 】对数据进行修改的事务与事务之间彼此隔离，相互独立，互不干扰！
【持久性	Durability 】事务完成后，对数据的修改，永久有效！

事务并发出现的问题：
1、脏读：事务 A 读取了事务 B 已回滚前的数据，则 A 读取到脏数据
2、丢失修改：事务 A、B同时修改同一数据，当两者共同获取数据并修改时，出现 B的修改覆盖了 A的修改！类似于并发编程中非原子操作 i++
2、不可重读：事务 A 多次访问 同一个数据，前后的结果不一样，可能是 事务B 对数据进行了并发的修改！
3、幻读：事务 A 使用同一条件进行查询，结果不一致，可能是 事务B 新增、删除了对应数据！

事务隔离级别：默认 可重复读
读未提交：事务 A 可读取 事务 B 未提交的数据————可能导致脏读，若事务B会滚，则脏读！
读已提交：事务 A 可读取 事务 B 已提交的数据————避免脏读，可能导致不可重读、幻读
可重复读：事务 A 读取数据时，加上 表锁，不允许其他事务对表进行修改————避免脏读和不可重复读，可能导致幻读（其他事务的insert操作）
串行化：级别最高，事务串行操作，性能最低：避免并发所有问题！

如和解决幻读：
	1、串行化
	2、MVCC+next-key locks
*/
```

##### 索引

```java
/*
【什么是索引】
	索引 是对数据库中 一个或者多个 列的值 进行排序 的数据结构，以协助 快速查询、更新数据库表中数据！

【索引底层数据结构】
（1）底层数据结构 是 B+树：多叉树
	数据结构中最常见的搜索结构就是 [ 二叉搜索树 ]，但是二叉搜索树会退化成单链表的情况，于是引出 [ AVL树（平衡二叉搜索树） ]，但是对于数据库来说，存储的数据量大，这会造成 树的深度过大，而造成 IO 频繁，使得查询效率低下！因此选用 多叉树，降低树的高度，保证较高的查询速率！
（2）为什么使用 B+ 树：
	B+ 树是 B树针对数据库的优化版本，非叶子结点上储存 键值，叶子结点上 存放数据，并且叶子结点之间构成列表，能够支持范围查询！这样做，能够加快查询速率，提高性能！

【主键】
	主键值得是 一列或者多列 的组合，其值能够唯一标识表中的每一行，通过它可以强制表的实体的完整性！

【索引分类】
· 唯一索引：唯一索引不允许出现两行相同的索引值，确保索引的唯一性！
· 主键索引：是唯一索引的特殊类型，主键索引不可为空，当定义一个主键时自动创建主键索引，一个表中只能有一个主键！
· 聚集索引：索引与数据存放在一个文件中，并且 索引键值的逻辑顺序 与 对应数据的顺序 相同，查询到索引时，便可获得对应数据！
· 非聚集索引：索引与数据分别在两个文件中，两者对应顺序不一致，获取完索引以后，还需要到另一个文件中获取对应数据！

【使用场景】
	索引用于优化查询数据，提高数据库查询性能！
	1、经常作为查询选择的字段：适合作为索引
	2、经常作为表连接的字段：适合作为索引
	3、经常出现在在order by、group by、distinct等关键字后面的字段：适合作为索引

【索引失效】
1、索引字段上使用函数，或者 计算索引字段！
2、索引字段出现隐式类型转换：字段为 varchar 类型，但是给出的是 int 类型
3、使用 复合索引（组合索引）时，不遵循最左前缀规则！
4、模糊查询时，出现前缀模糊查询，即 like %abc
	这是因为 B+树 索引的结构，需要从左往右匹配键值，以 % 开头，无法进行索引查询！
5、如果 mysql 优化器 觉得，使用索引 比全表扫描慢，则会放弃使用 索引
6、or 查询条件会走全表扫描

【索引优化】
0、查询时，列出所要查询的字段，不能 select * ，会返回不需要的字段！

1、使用短索引：索引长度不宜过长，如果索引前n个字符就能确定数据的唯一性，则可以指定该字段的前缀长度为一个索引！短索引可以提高查询速度，节省磁盘IO

2、避免全表扫描：使用 explain 查看执行计划时，若 type 为 ALL 则是全表扫描

3、避免不等值判断
	应尽量避免在 where字句 中使用 "!= < >"等判断，否则mysql将放弃使用索引，而进行全表扫描
	
4、避免使用 or 逻辑
	使用 or 时，只有当 select 后面的列为 索引列，并且 or 前后必须同属于符合索引中的列，才会使用索引！

5、慎用 in 和 not in 查询
	in 一般来说会使用 索引，但是如果使用 in + 套字查询 ，则外层循环 将会做全表扫描，可以将其改成 表连接！
	或者 使用 exists 替换 in 查询！
    例如：select id from t1 where num in(select id from t2 where id > 10);此时外层查询会全表扫描
    改成：select id from t1,(select id from t1 where id > 10)t2 where t1.id = t2.id;改为表连接查询
    
    not in 不会使用 索引！
6、注意模糊查询
	模糊不可使用 模糊头匹配！不会使用索引！
7、避免在 查询条件中计算索引字段！
	例如 		select id from t where num/2=100	
	应改为:	select id from t where num=100*2
8、where 字句 "=" 左边需要注意：
	不要在 左边 进行 函数、算数运算 或者 其他表达式 运算，否则系统将无法正确使用索引！
9、复合索引
	必须满足最左前缀原则！
10、表联接：外联 优于 内联！
	因为 外连接有基础数据：
	如 A left join B	：基础数据是 A
	而内联：A inner join B ：无基础数据，会先使用 笛卡尔积，再根据联接条件得到内联接结果集
11、尽量不使用 * 、union、union all 、or关键字，尽量使用 等值查询！

12、尽量避免 where 字句中进行 null 值判断，否则引擎将放弃索引，而全表扫描
13、优化嵌套拆线呢：子查询 可以 被更有效率的 Join 替代
*/
```

##### 非关系型 vs 关系型

```java
/*
非关系型数据库的优势：
    性能：NOSQL是基于键值对，可以想象成表中的主键和值的对应关系，不需要经过SQL层的解析，所以性能非常高。
    可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
   
关系型数据库的优势：
    复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
    事务支持：使得对于安全性能很高的数据访问要求得以实现。
   
其他:
    1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。
    2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。
    3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。
*/
```

##### 完整性约束

详见：[5种完整性约束](https://blog.csdn.net/sinat_26342009/article/details/46420269)

```mysql
/*
示例：
	主键约束 primary key
	非空约束 not noll
	唯一性约束 unique
	外键约束：foreign key
	检查约束：check (mysql中不支持)
*/
create table `student`{
	`stu_id` int(11) primary key comment'id',
	`stu_name` varchar(32) not null unique comment'姓名'
};
```

9. 数据库判断语法错误,我记得是having错了

10. 数据库相关判断